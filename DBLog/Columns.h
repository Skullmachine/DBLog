#pragma once

#ifndef __COLUMNS_H_
#define __COLUMNS_H_

#include "stdafx.h"
#include "enums.h"
#include "DBLogUtil.h"
#include <vector>

class CTSDatalink;
class Statement;

class DBMemoryBuilder { 

public:
	DBMemoryBuilder(ColDataType type);
	void Append(TS::PropertyObjectPtr &pValue, _bstr_t &format, int depth = 1, _bstr_t prefix = L"");
	void Write(ADOLoggingObject &pDBObj, _bstr_t &name, unsigned int maxByteSize = 0);

private:

	void AppendNumber(TS::PropertyObjectPtr &pValue, VARTYPE numType = VT_R8);
	void AppendString(TS::PropertyObjectPtr &pValue, _bstr_t prefix = L"", bool escapeCRLF = false);
	void AppendBoolean(TS::PropertyObjectPtr &pValue, VARTYPE numType);

	//void AppendDate(_bstr_t value, char* format);
	unsigned int GetNumArrayElements(variant_t vArray, unsigned int *elementSize = NULL);
	void AppendStringArray(TS::PropertyObjectPtr &pValue /*, wchar_t *delimeter = L"\r\n", bool escapeCRLF = true */);
	void AppendNumericArray(TS::PropertyObjectPtr &pValue, VARTYPE format /*, wchar_t *delimeter = L"\n" */);
	void AppendBooleanArray(TS::PropertyObjectPtr &pValue, VARTYPE numType /*, wchar_t *delimeter = L"\r\n" */);
	void WriteStringValues(ADOLoggingObject &pDBObj, _bstr_t &name, unsigned int maxByteSize = 0);
	void WriteBinaryValues(ADOLoggingObject &pDBObj, _bstr_t &name, unsigned int maxByteSize = 0);
    void WriteBinaryArray(ADOLoggingObject &pDBObj, _bstr_t &name, variant_t &value, unsigned int maxByteSize, unsigned int &bytesWritten, bool &stop);
    void WriteBinaryValue(ADOLoggingObject &pDBObj, _bstr_t &name, variant_t &value, unsigned int maxByteSize, unsigned int &bytesWritten, bool &stop);
	void DBMemoryBuilder::WriteBinaryZeros(ADOLoggingObject &pDBObj, _bstr_t &name, unsigned int bytes);

	void ChangeArrayType(variant_t &vArray, VARTYPE vtNewType);
	void EscapeCRLF(_bstr_t &stringValue);
	int GetNumTypeSizeFromFormat(VARTYPE numType);
	VARTYPE GetNumTypeFromFormat(const _bstr_t &format, VARTYPE defaultVarType);

	ColDataType m_type;
	std::vector<_variant_t>	m_Values;
	unsigned int m_totalBytes;
};

class CDbColumn { 
public:
    CDbColumn(TS::IEnginePtr& pEngine, TS::PropertyObjectPtr& pDBColumn, Statement* pStmt);
	//CDbColumn(){};
    ~CDbColumn();

	void					InitForeignKeyInformation(void);

    // convenience accessor for Column name
    _bstr_t					GetName()				{return m_name;}
	_bstr_t					GetForeignKeyName()		{return m_foreignKeyName;}
	ColDataType				GetType()				{return m_type;}
	ParameterDirectionEnum	GetDirection()			{return m_direction;}
	DataTypeEnum			GetAdoType()			{return m_AdoType;}
	unsigned int			GetSize()				{return m_size;}
	bool					IsAutoGeneratedKey()	{return m_isPrimaryKey && m_primaryKeyType == tsDBOptionsPrimaryKeyType_AutoGenerated;}
	bool					IsPrimaryKey()			{return m_isPrimaryKey;}
	bool					IsForeignKey()			{return m_isForeignKey;}
	bool					IsStepRecursiveKey()	{return m_isStepRecursiveKey;}
	Statement *				GetForeignKeyStmt()		{return m_pForeignKeyStmt;}

    // record data into appropriate field
    void SetColumn(LoggingInfo &loggingInfo, ADOLoggingObject &pDBObj, int depth = -1);

	void UpdateOutputValue(LoggingInfo &logging, _variant_t value);

private:
    _bstr_t					m_name;					// column/field name
    ColDataType				m_type;					// data type of column/field
	ParameterDirectionEnum	m_direction;			//ado parameter direction, also column data direction
	DataTypeEnum			m_AdoType;				//ado data type
    TS::ExpressionPtr		m_expressionExpr;		// expression which yields data to store
    unsigned int			m_size;					// size limit for string/binary columns
    _bstr_t					m_format;				// time/date format
	TS::ExpressionPtr		m_preconditionExpr;		// determines whether to include column
	std::vector<_bstr_t>	m_expectedProperties;	// properties to look for before logging

    bool					m_isPrimaryKey;         
    PrimaryKeyTypes			m_primaryKeyType;		// auto-generated or user-constructed
    _bstr_t					m_primaryKeyStatement;	// SQL to generate primary key
	Command25Ptr			m_pPrimaryKeyCommand;	//ado command pointer for prepared key statement

    bool					m_isForeignKey;         
    _bstr_t					m_foreignKeyName;		// obtain this statement's foreign key
    Statement *				m_pStatement;			// statement the column is under
	Statement *				m_pForeignKeyStmt;		// statement the foreign key column references
	bool					m_isStepRecursiveKey;	// indicates whether the foreign key references the same statement as is parent statement

	//gets value of foreign key
	void GetForeignKeyValue(LoggingInfo &loggingInfo, _variant_t &KeyVal, int depth = -1);
	void GetPrimaryKeyValue(LoggingInfo &loggingInfo, _variant_t &KeyVal);

	//returns formatted time string
	void GetDateTimeValue( _bstr_t str, _variant_t &timeVariant);

    // sets field with the primary key from the foreign key statement
	void SetForeignKey(LoggingInfo &loggingInfo, ADOLoggingObject &pDBObj, int depth = -1);

    // sets field with the result from the primary key statement
	void SetPrimaryKey(LoggingInfo &loggingInfo, ADOLoggingObject &pDBObj);

 	//validate conditions common to SetColumn()
	bool ValidatePreConditions(LoggingInfo &loggingInfo);

	static _bstr_t GetColumnStatus(long status);
};


// definition for a collection of columns
typedef CList<CDbColumn*, CDbColumn*> Columns;

#endif