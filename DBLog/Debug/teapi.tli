// Created by Microsoft (R) C/C++ Compiler Version 10.00.40219.01 (c52688eb).
//
// c:\program files (x86)\national instruments\teststand 4.2.1\components\models\teststandmodels\database\dblog\debug\teapi.tli
//
// Wrapper implementations for Win32 type library ..\..\bin\teapi.dll
// compiler-generated file created 03/17/16 at 23:42:02 - DO NOT EDIT!

#pragma once

namespace TS {

//
// interface SearchMatch wrapper method implementations
//

HRESULT SearchMatch::GetLocation ( long * matchElement, long * matchStart, long * matchLength ) {
    HRESULT _hr = raw_GetLocation(matchElement, matchStart, matchLength);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t SearchMatch::GetPropertyPath ( VARIANT_BOOL useNamesForIndices ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetPropertyPath(useNamesForIndices, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t SearchMatch::GetMatchedText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MatchedText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t SearchMatch::GetFileDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileDisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t SearchMatch::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long SearchMatch::GetFileId ( ) {
    long _result = 0;
    HRESULT _hr = get_FileId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SearchMatch::UpdateForReplace ( _bstr_t replacementString ) {
    HRESULT _hr = raw_UpdateForReplace(replacementString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum TypeCategories SearchMatch::GetTypeCategoryOfMatch ( ) {
    enum TypeCategories _result;
    HRESULT _hr = get_TypeCategoryOfMatch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SearchMatch::GetUserData ( ) {
    long _result = 0;
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SearchMatch::PutUserData ( long val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SearchMatch::GetPropertyValueAsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PropertyValueAsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum PropertyValueTypes SearchMatch::GetPropertyValueType ( ) {
    enum PropertyValueTypes _result;
    HRESULT _hr = get_PropertyValueType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SearchMatch::UpdateForReplaceValue ( _bstr_t newValue ) {
    HRESULT _hr = raw_UpdateForReplaceValue(newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL SearchMatch::GetMatchIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MatchIsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface SearchResults wrapper method implementations
//

HRESULT SearchResults::Cancel ( VARIANT_BOOL waitForComplete, VARIANT_BOOL processWindowsMsgsWhileWaiting ) {
    HRESULT _hr = raw_Cancel(waitForComplete, processWindowsMsgsWhileWaiting);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL SearchResults::IsComplete ( VARIANT_BOOL waitForComplete, VARIANT_BOOL processWindowsMsgsWhileWaiting ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsComplete(waitForComplete, processWindowsMsgsWhileWaiting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SearchResults::GetNumMatches ( ) {
    long _result = 0;
    HRESULT _hr = get_NumMatches(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SearchMatchPtr SearchResults::GetMatch ( long index ) {
    struct SearchMatch * _result = 0;
    HRESULT _hr = raw_GetMatch(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SearchMatchPtr(_result, false);
}

_bstr_t SearchResults::GetStatusMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StatusMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long SearchResults::GetNumWarnings ( ) {
    long _result = 0;
    HRESULT _hr = get_NumWarnings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t SearchResults::GetWarning ( long index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetWarning(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ArrayDimensions wrapper method implementations
//

SAFEARRAY * ArrayDimensions::GetLowerBounds ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLowerBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * ArrayDimensions::GetUpperBounds ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetUpperBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT ArrayDimensions::SetBounds ( SAFEARRAY * lowerBounds, SAFEARRAY * upperBounds ) {
    HRESULT _hr = raw_SetBounds(lowerBounds, upperBounds);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t ArrayDimensions::GetLowerBoundsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LowerBoundsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t ArrayDimensions::GetUpperBoundsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UpperBoundsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT ArrayDimensions::SetBoundsByStrings ( _bstr_t lowerBounds, _bstr_t upperBounds ) {
    HRESULT _hr = raw_SetBoundsByStrings(lowerBounds, upperBounds);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * ArrayDimensions::GetDimensionsSizes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetDimensionsSizes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t ArrayDimensions::GetDisplayString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface PropertyObjectType wrapper method implementations
//

enum PropertyValueTypes PropertyObjectType::GetValueType ( ) {
    enum PropertyValueTypes _result;
    HRESULT _hr = get_ValueType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObjectType::GetIsObject ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t PropertyObjectType::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

PropertyObjectTypePtr PropertyObjectType::GetElementType ( ) {
    struct PropertyObjectType * _result = 0;
    HRESULT _hr = get_ElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectTypePtr(_result, false);
}

_bstr_t PropertyObjectType::GetDisplayString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

ArrayDimensionsPtr PropertyObjectType::GetArrayDimensions ( ) {
    struct ArrayDimensions * _result = 0;
    HRESULT _hr = get_ArrayDimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ArrayDimensionsPtr(_result, false);
}

VARIANT_BOOL PropertyObjectType::IsEqualTo ( struct PropertyObjectType * propObjType, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsEqualTo(propObjType, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface CodeTemplate wrapper method implementations
//

enum CodeTemplateTypes CodeTemplate::GetType ( ) {
    enum CodeTemplateTypes _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t CodeTemplate::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t CodeTemplate::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface CodeTemplates wrapper method implementations
//

CodeTemplatePtr CodeTemplates::GetItem ( const _variant_t & index ) {
    struct CodeTemplate * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CodeTemplatePtr(_result, false);
}

IUnknownPtr CodeTemplates::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long CodeTemplates::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface SearchDirectory wrapper method implementations
//

enum SearchDirectoryTypes SearchDirectory::GetType ( ) {
    enum SearchDirectoryTypes _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t SearchDirectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SearchDirectory::PutPath ( _bstr_t val ) {
    HRESULT _hr = put_Path(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SearchDirectory::GetSearchSubdirectories ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SearchSubdirectories(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SearchDirectory::PutSearchSubdirectories ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SearchSubdirectories(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SearchDirectory::GetFileExtensionRestrictions ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileExtensionRestrictions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SearchDirectory::PutFileExtensionRestrictions ( _bstr_t val ) {
    HRESULT _hr = put_FileExtensionRestrictions(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SearchDirectory::GetExcludeFileExtension ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExcludeFileExtension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SearchDirectory::PutExcludeFileExtension ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ExcludeFileExtension(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SearchDirectory::GetDisabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Disabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SearchDirectory::PutDisabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Disabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface SearchDirectories wrapper method implementations
//

SearchDirectoryPtr SearchDirectories::GetItem ( const _variant_t & index ) {
    struct SearchDirectory * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SearchDirectoryPtr(_result, false);
}

IUnknownPtr SearchDirectories::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long SearchDirectories::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SearchDirectories::Insert ( _bstr_t Path, long index, VARIANT_BOOL searchSubDirs, _bstr_t fileExtRestrict, VARIANT_BOOL exclude, VARIANT_BOOL Disabled ) {
    HRESULT _hr = raw_Insert(Path, index, searchSubDirs, fileExtRestrict, exclude, Disabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SearchDirectories::Remove ( long index ) {
    HRESULT _hr = raw_Remove(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SearchDirectories::MoveSearchDirectory ( long index, long newIndex ) {
    HRESULT _hr = raw_MoveSearchDirectory(index, newIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SearchDirectories::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ExternalReportViewer wrapper method implementations
//

_bstr_t ExternalReportViewer::GetFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Format(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExternalReportViewer::PutFormat ( _bstr_t val ) {
    HRESULT _hr = put_Format(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExternalReportViewer::GetArguments ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Arguments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExternalReportViewer::PutArguments ( _bstr_t val ) {
    HRESULT _hr = put_Arguments(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExternalReportViewer::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExternalReportViewer::PutPath ( _bstr_t val ) {
    HRESULT _hr = put_Path(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ExternalReportViewer::GetAutoLaunch ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoLaunch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExternalReportViewer::PutAutoLaunch ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoLaunch(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ExternalReportViewers wrapper method implementations
//

ExternalReportViewerPtr ExternalReportViewers::GetItem ( const _variant_t & index ) {
    struct ExternalReportViewer * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExternalReportViewerPtr(_result, false);
}

IUnknownPtr ExternalReportViewers::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long ExternalReportViewers::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT ExternalReportViewers::Add ( _bstr_t Format, _bstr_t Path, _bstr_t Arguments, VARIANT_BOOL AutoLaunch ) {
    HRESULT _hr = raw_Add(Format, Path, Arguments, AutoLaunch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ExternalReportViewers::Remove ( long index ) {
    HRESULT _hr = raw_Remove(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL ExternalReportViewers::GetAutoLaunchDefaultExternalViewers ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoLaunchDefaultExternalViewers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExternalReportViewers::PutAutoLaunchDefaultExternalViewers ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AutoLaunchDefaultExternalViewers(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface EvaluationTypes wrapper method implementations
//

long EvaluationTypes::GetPropertyValueTypeFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_PropertyValueTypeFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EvaluationTypes::PutPropertyValueTypeFlags ( long val ) {
    HRESULT _hr = put_PropertyValueTypeFlags(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * EvaluationTypes::GetNamedTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_NamedTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EvaluationTypes::PutNamedTypes ( SAFEARRAY * val ) {
    HRESULT _hr = put_NamedTypes(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * EvaluationTypes::GetArrayOfNamedTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ArrayOfNamedTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EvaluationTypes::PutArrayOfNamedTypes ( SAFEARRAY * val ) {
    HRESULT _hr = put_ArrayOfNamedTypes(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface StationOptions wrapper method implementations
//

_bstr_t StationOptions::GetUserFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StationOptions::PutUserFilePath ( _bstr_t val ) {
    HRESULT _hr = put_UserFilePath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetEnableUserPrivilegeChecking ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableUserPrivilegeChecking(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutEnableUserPrivilegeChecking ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_EnableUserPrivilegeChecking(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetAutoLoginSystemUser ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoLoginSystemUser(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAutoLoginSystemUser ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_AutoLoginSystemUser(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetRequireUserLogin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RequireUserLogin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutRequireUserLogin ( VARIANT_BOOL requireUser ) {
    HRESULT _hr = put_RequireUserLogin(requireUser);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum RTEOptions StationOptions::GetRTEOption ( ) {
    enum RTEOptions _result;
    HRESULT _hr = get_RTEOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutRTEOption ( enum RTEOptions option ) {
    HRESULT _hr = put_RTEOption(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetTracingEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TracingEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutTracingEnabled ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_TracingEnabled(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetBreakpointsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakpointsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutBreakpointsEnabled ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_BreakpointsEnabled(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetDisableResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DisableResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutDisableResults ( VARIANT_BOOL isDisabled ) {
    HRESULT _hr = put_DisableResults(isDisabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetAlwaysGotoCleanupOnFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AlwaysGotoCleanupOnFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAlwaysGotoCleanupOnFailure ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AlwaysGotoCleanupOnFailure(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetExecutionMask ( ) {
    long _result = 0;
    HRESULT _hr = get_ExecutionMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutExecutionMask ( long val ) {
    HRESULT _hr = put_ExecutionMask(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum InteractiveBranchModes StationOptions::GetInteractiveBranchMode ( ) {
    enum InteractiveBranchModes _result;
    HRESULT _hr = get_InteractiveBranchMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutInteractiveBranchMode ( enum InteractiveBranchModes mode ) {
    HRESULT _hr = put_InteractiveBranchMode(mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetTimeLimitEnabled ( enum TimeLimitTypes Type, enum TimeLimitOperations operation ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetTimeLimitEnabled(Type, operation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT StationOptions::SetTimeLimitEnabled ( enum TimeLimitTypes Type, enum TimeLimitOperations operation, VARIANT_BOOL enabled ) {
    HRESULT _hr = raw_SetTimeLimitEnabled(Type, operation, enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double StationOptions::GetTimeLimit ( enum TimeLimitTypes Type, enum TimeLimitOperations operation ) {
    double _result = 0;
    HRESULT _hr = raw_GetTimeLimit(Type, operation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT StationOptions::SetTimeLimit ( enum TimeLimitTypes Type, enum TimeLimitOperations operation, double timeLimit ) {
    HRESULT _hr = raw_SetTimeLimit(Type, operation, timeLimit);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum TimeLimitActions StationOptions::GetTimeLimitAction ( enum TimeLimitTypes Type, enum TimeLimitOperations operation ) {
    enum TimeLimitActions _result;
    HRESULT _hr = raw_GetTimeLimitAction(Type, operation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT StationOptions::SetTimeLimitAction ( enum TimeLimitTypes Type, enum TimeLimitOperations operation, enum TimeLimitActions action ) {
    HRESULT _hr = raw_SetTimeLimitAction(Type, operation, action);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL StationOptions::GetShowHiddenProperties ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowHiddenProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutShowHiddenProperties ( VARIANT_BOOL show ) {
    HRESULT _hr = put_ShowHiddenProperties(show);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetPromptToFindFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PromptToFindFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutPromptToFindFiles ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_PromptToFindFiles(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FileVersionAutoIncrement StationOptions::GetSeqFileVersionAutoIncrementOpt ( ) {
    enum FileVersionAutoIncrement _result;
    HRESULT _hr = get_SeqFileVersionAutoIncrementOpt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutSeqFileVersionAutoIncrementOpt ( enum FileVersionAutoIncrement option ) {
    HRESULT _hr = put_SeqFileVersionAutoIncrementOpt(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TypeVersionAutoIncrement StationOptions::GetTypeVersionAutoIncrementOpt ( ) {
    enum TypeVersionAutoIncrement _result;
    HRESULT _hr = get_TypeVersionAutoIncrementOpt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutTypeVersionAutoIncrementOpt ( enum TypeVersionAutoIncrement option ) {
    HRESULT _hr = put_TypeVersionAutoIncrementOpt(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetTypeVersionAutoIncrementPromptOpt ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TypeVersionAutoIncrementPromptOpt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutTypeVersionAutoIncrementPromptOpt ( VARIANT_BOOL option ) {
    HRESULT _hr = put_TypeVersionAutoIncrementPromptOpt(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetReloadDocsWhenOpeningWorkspace ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReloadDocsWhenOpeningWorkspace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutReloadDocsWhenOpeningWorkspace ( VARIANT_BOOL reloadDocs ) {
    HRESULT _hr = put_ReloadDocsWhenOpeningWorkspace(reloadDocs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetReloadWorkspaceAtStartup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReloadWorkspaceAtStartup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutReloadWorkspaceAtStartup ( VARIANT_BOOL reloadWorkspace ) {
    HRESULT _hr = put_ReloadWorkspaceAtStartup(reloadWorkspace);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StationOptions::GetStationID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StationID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StationOptions::PutStationID ( _bstr_t val ) {
    HRESULT _hr = put_StationID(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void StationOptions::PutSpecifyStepsByUniqueIdInExpressions ( enum SpecifyStepsByUniqueIdOptions option ) {
    HRESULT _hr = put_SpecifyStepsByUniqueIdInExpressions(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SpecifyStepsByUniqueIdOptions StationOptions::GetSpecifyStepsByUniqueIdInExpressions ( ) {
    enum SpecifyStepsByUniqueIdOptions _result;
    HRESULT _hr = get_SpecifyStepsByUniqueIdInExpressions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL StationOptions::GetUseStationModel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseStationModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutUseStationModel ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_UseStationModel(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetAllowOtherModels ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowOtherModels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAllowOtherModels ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AllowOtherModels(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StationOptions::GetStationModelSequenceFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StationModelSequenceFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StationOptions::PutStationModelSequenceFilePath ( _bstr_t ModelPath ) {
    HRESULT _hr = put_StationModelSequenceFilePath(ModelPath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StationOptions::GetLanguage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Language(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StationOptions::PutLanguage ( _bstr_t Language ) {
    HRESULT _hr = put_Language(Language);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetUseLocalizedDecimalPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseLocalizedDecimalPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutUseLocalizedDecimalPoint ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_UseLocalizedDecimalPoint(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetRecognizeMBChars ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RecognizeMBChars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutRecognizeMBChars ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_RecognizeMBChars(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * StationOptions::GetLanguages ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLanguages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL StationOptions::GetAllowSequenceCallsFromRemoteMachine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowSequenceCallsFromRemoteMachine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAllowSequenceCallsFromRemoteMachine ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AllowSequenceCallsFromRemoteMachine(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetAllowAllUsersAccessFromRemoteMachine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowAllUsersAccessFromRemoteMachine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAllowAllUsersAccessFromRemoteMachine ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AllowAllUsersAccessFromRemoteMachine(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetShowEngineTrayIconOnRemoteStations ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowEngineTrayIconOnRemoteStations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutShowEngineTrayIconOnRemoteStations ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_ShowEngineTrayIconOnRemoteStations(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetCheckOutFilesWhenEdited ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CheckOutFilesWhenEdited(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutCheckOutFilesWhenEdited ( VARIANT_BOOL checkOutFiles ) {
    HRESULT _hr = put_CheckOutFilesWhenEdited(checkOutFiles);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetPromptWhenAddingFilesToSC ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PromptWhenAddingFilesToSC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutPromptWhenAddingFilesToSC ( VARIANT_BOOL promptAddFile ) {
    HRESULT _hr = put_PromptWhenAddingFilesToSC(promptAddFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetUseDialogForCheckOut ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseDialogForCheckOut(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutUseDialogForCheckOut ( VARIANT_BOOL useDialog ) {
    HRESULT _hr = put_UseDialogForCheckOut(useDialog);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetCheckOutOnlySelectedFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CheckOutOnlySelectedFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutCheckOutOnlySelectedFiles ( VARIANT_BOOL onlySelectedFiles ) {
    HRESULT _hr = put_CheckOutOnlySelectedFiles(onlySelectedFiles);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StationOptions::GetSystemDefaultSourceCodeControlProvider ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SystemDefaultSourceCodeControlProvider(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StationOptions::PutSystemDefaultSourceCodeControlProvider ( _bstr_t val ) {
    HRESULT _hr = put_SystemDefaultSourceCodeControlProvider(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetUIMessageDelay ( ) {
    long _result = 0;
    HRESULT _hr = get_UIMessageDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutUIMessageDelay ( long millisecDelay ) {
    HRESULT _hr = put_UIMessageDelay(millisecDelay);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetUIMessageMinDelay ( ) {
    long _result = 0;
    HRESULT _hr = get_UIMessageMinDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutUIMessageMinDelay ( long millisecDelay ) {
    HRESULT _hr = put_UIMessageMinDelay(millisecDelay);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetInteractiveExePropagateStatus ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InteractiveExePropagateStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutInteractiveExePropagateStatus ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_InteractiveExePropagateStatus(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetBreakOnStepFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnStepFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutBreakOnStepFailure ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_BreakOnStepFailure(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StationOptions::GetBreakOnSequenceFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnSequenceFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutBreakOnSequenceFailure ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_BreakOnSequenceFailure(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetDebugOptions ( ) {
    long _result = 0;
    HRESULT _hr = get_DebugOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutDebugOptions ( long val ) {
    HRESULT _hr = put_DebugOptions(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FileWritingFormats StationOptions::GetDefaultFileWritingFormat ( ) {
    enum FileWritingFormats _result;
    HRESULT _hr = get_DefaultFileWritingFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutDefaultFileWritingFormat ( enum FileWritingFormats returnVal ) {
    HRESULT _hr = put_DefaultFileWritingFormat(returnVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AllowAutomaticTypeConflictResolutionOptions StationOptions::GetAllowAutomaticTypeConflictResolution ( ) {
    enum AllowAutomaticTypeConflictResolutionOptions _result;
    HRESULT _hr = get_AllowAutomaticTypeConflictResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutAllowAutomaticTypeConflictResolution ( enum AllowAutomaticTypeConflictResolutionOptions val ) {
    HRESULT _hr = put_AllowAutomaticTypeConflictResolution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetFileModificationIndicatorPolicy ( ) {
    long _result = 0;
    HRESULT _hr = get_FileModificationIndicatorPolicy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutFileModificationIndicatorPolicy ( long val ) {
    HRESULT _hr = put_FileModificationIndicatorPolicy(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StationOptions::GetDefaultCPUAffinityForThreads ( ) {
    long _result = 0;
    HRESULT _hr = get_DefaultCPUAffinityForThreads(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StationOptions::PutDefaultCPUAffinityForThreads ( long val ) {
    HRESULT _hr = put_DefaultCPUAffinityForThreads(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Images wrapper method implementations
//

IPicturePtr Images::GetItem ( long imageIndex ) {
    struct IPicture * _result = 0;
    HRESULT _hr = get_Item(imageIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPicturePtr(_result, false);
}

long Images::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPicturePtr Images::FindImage ( _bstr_t IconName, long desiredWidth, long desiredHeight ) {
    struct IPicture * _result = 0;
    HRESULT _hr = raw_FindImage(IconName, desiredWidth, desiredHeight, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPicturePtr(_result, false);
}

//
// interface Location wrapper method implementations
//

enum LocationKinds Location::GetKind ( ) {
    enum LocationKinds _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutKind ( enum LocationKinds val ) {
    HRESULT _hr = put_Kind(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutFilePath ( _bstr_t val ) {
    HRESULT _hr = put_FilePath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetFileId ( ) {
    long _result = 0;
    HRESULT _hr = get_FileId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutFileId ( long val ) {
    HRESULT _hr = put_FileId(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetFileDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileDisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutFileDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_FileDisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetPropertyPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PropertyPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutPropertyPath ( _bstr_t val ) {
    HRESULT _hr = put_PropertyPath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetPropertyPathWithNames ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PropertyPathWithNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutPropertyPathWithNames ( _bstr_t val ) {
    HRESULT _hr = put_PropertyPathWithNames(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetSequenceName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutSequenceName ( _bstr_t val ) {
    HRESULT _hr = put_SequenceName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum StepGroups Location::GetStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutStepGroup ( enum StepGroups val ) {
    HRESULT _hr = put_StepGroup(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetStepName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StepName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutStepName ( _bstr_t val ) {
    HRESULT _hr = put_StepName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetStepId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StepId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutStepId ( _bstr_t val ) {
    HRESULT _hr = put_StepId(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_StepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutStepIndex ( long val ) {
    HRESULT _hr = put_StepIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetExecutionId ( ) {
    long _result = 0;
    HRESULT _hr = get_ExecutionId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutExecutionId ( long val ) {
    HRESULT _hr = put_ExecutionId(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetExecutionDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ExecutionDisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutExecutionDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_ExecutionDisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetThreadId ( ) {
    long _result = 0;
    HRESULT _hr = get_ThreadId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutThreadId ( long val ) {
    HRESULT _hr = put_ThreadId(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetContextId ( ) {
    long _result = 0;
    HRESULT _hr = get_ContextId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutContextId ( long val ) {
    HRESULT _hr = put_ContextId(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutTypeName ( _bstr_t val ) {
    HRESULT _hr = put_TypeName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TypeCategories Location::GetTypeCategory ( ) {
    enum TypeCategories _result;
    HRESULT _hr = get_TypeCategory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutTypeCategory ( enum TypeCategories val ) {
    HRESULT _hr = put_TypeCategory(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum PropertyObjectElements Location::GetElement ( ) {
    enum PropertyObjectElements _result;
    HRESULT _hr = get_Element(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutElement ( enum PropertyObjectElements val ) {
    HRESULT _hr = put_Element(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetSelStart ( ) {
    long _result = 0;
    HRESULT _hr = get_SelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutSelStart ( long val ) {
    HRESULT _hr = put_SelStart(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Location::GetSelLength ( ) {
    long _result = 0;
    HRESULT _hr = get_SelLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Location::PutSelLength ( long val ) {
    HRESULT _hr = put_SelLength(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Location::GetThreadDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ThreadDisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Location::PutThreadDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_ThreadDisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface FileInformation wrapper method implementations
//

VARIANT_BOOL FileInformation::GetFileExists ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FileExists(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL FileInformation::GetIsCustomFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCustomFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL FileInformation::GetIsSequenceFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL FileInformation::GetIsPropertyObjectFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum FileWritingFormats FileInformation::GetFileWritingFormat ( ) {
    enum FileWritingFormats _result;
    HRESULT _hr = get_FileWritingFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t FileInformation::GetFileFormatVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetFileFormatVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL FileInformation::GetFileVersion ( BSTR * val ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetFileVersion(val, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Utility wrapper method implementations
//

_bstr_t Utility::Escape ( _bstr_t stringToEscape, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Escape(stringToEscape, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t Utility::Unescape ( _bstr_t stringToUnescape, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Unescape(stringToUnescape, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// dispinterface _TEEngineEvents wrapper method implementations
//

HRESULT _TEEngineEvents::UIMessageEvent ( struct UIMessage * msg ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", msg);
}

//
// interface InputStream wrapper method implementations
//

SAFEARRAY * InputStream::ReadBytes ( long numBytes ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ReadBytes(numBytes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL InputStream::GetIsEndofStream ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEndofStream(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InputStream::GetLength ( ) {
    long _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InputStream::GetOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_Offset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InputStream::PutOffset ( long val ) {
    HRESULT _hr = put_Offset(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t InputStream::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface PropertyObject wrapper method implementations
//

double PropertyObject::GetValNumber ( _bstr_t lookupString, long options ) {
    double _result = 0;
    HRESULT _hr = raw_GetValNumber(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetValNumber ( _bstr_t lookupString, long options, double newValue ) {
    HRESULT _hr = raw_SetValNumber(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObject::GetValBoolean ( _bstr_t lookupString, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetValBoolean(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetValBoolean ( _bstr_t lookupString, long options, VARIANT_BOOL newValue ) {
    HRESULT _hr = raw_SetValBoolean(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetValString ( _bstr_t lookupString, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetValString(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT PropertyObject::SetValString ( _bstr_t lookupString, long options, _bstr_t newValue ) {
    HRESULT _hr = raw_SetValString(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr PropertyObject::GetPropertyObject ( _bstr_t lookupString, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetPropertyObject(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT PropertyObject::SetPropertyObject ( _bstr_t lookupString, long options, struct PropertyObject * newValue ) {
    HRESULT _hr = raw_SetPropertyObject(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t PropertyObject::GetValVariant ( _bstr_t lookupString, long options ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValVariant(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT PropertyObject::SetValVariant ( _bstr_t lookupString, long options, const _variant_t & newValue ) {
    HRESULT _hr = raw_SetValVariant(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IDispatchPtr PropertyObject::GetValIDispatch ( _bstr_t lookupString, long options ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_GetValIDispatch(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

HRESULT PropertyObject::SetValIDispatch ( _bstr_t lookupString, long options, IDispatch * newValue ) {
    HRESULT _hr = raw_SetValIDispatch(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IUnknownPtr PropertyObject::GetValInterface ( _bstr_t lookupString, long options ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_GetValInterface(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT PropertyObject::SetValInterface ( _bstr_t lookupString, long options, IUnknown * newValue ) {
    HRESULT _hr = raw_SetValInterface(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long PropertyObject::GetFlags ( _bstr_t lookupString, long options ) {
    long _result = 0;
    HRESULT _hr = raw_GetFlags(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetFlags ( _bstr_t lookupString, long options, long Flags ) {
    HRESULT _hr = raw_SetFlags(lookupString, options, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum PropertyValueTypes PropertyObject::GetType ( _bstr_t lookupString, long options, VARIANT_BOOL * IsObject, VARIANT_BOOL * IsArray, BSTR * typeNameParam ) {
    enum PropertyValueTypes _result;
    HRESULT _hr = raw_GetType(lookupString, options, IsObject, IsArray, typeNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr PropertyObject::GetTypeDefinition ( _bstr_t lookupString, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetTypeDefinition(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT PropertyObject::GetDimensions ( _bstr_t lookupString, long options, BSTR * lowerBounds, BSTR * upperBounds, long * numElements, enum PropertyValueTypes * ElementType ) {
    HRESULT _hr = raw_GetDimensions(lookupString, options, lowerBounds, upperBounds, numElements, ElementType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::SetDimensions ( _bstr_t lookupString, long options, _bstr_t lowerBounds, _bstr_t upperBounds ) {
    HRESULT _hr = raw_SetDimensions(lookupString, options, lowerBounds, upperBounds);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetArrayIndex ( _bstr_t lookupString, long options, long arrayOffset ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetArrayIndex(lookupString, options, arrayOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long PropertyObject::GetArrayOffset ( _bstr_t lookupString, long options, _bstr_t arrayIndex ) {
    long _result = 0;
    HRESULT _hr = raw_GetArrayOffset(lookupString, options, arrayIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::NewSubProperty ( _bstr_t lookupString, enum PropertyValueTypes ValueType, VARIANT_BOOL asArray, _bstr_t typeNameParam, long options ) {
    HRESULT _hr = raw_NewSubProperty(lookupString, ValueType, asArray, typeNameParam, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::DeleteSubProperty ( _bstr_t lookupString, long options ) {
    HRESULT _hr = raw_DeleteSubProperty(lookupString, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long PropertyObject::GetNumSubProperties ( _bstr_t lookupString ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumSubProperties(lookupString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t PropertyObject::GetNthSubPropertyName ( _bstr_t lookupString, long index, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetNthSubPropertyName(lookupString, index, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT PropertyObject::SetNthSubPropertyName ( _bstr_t lookupString, long index, long options, _bstr_t newValue ) {
    HRESULT _hr = raw_SetNthSubPropertyName(lookupString, index, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObject::Exists ( _bstr_t lookupString, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Exists(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr PropertyObject::Clone ( _bstr_t lookupString, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_Clone(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr PropertyObject::Evaluate ( _bstr_t exprString ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_Evaluate(exprString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT PropertyObject::Write ( _bstr_t pathString, _bstr_t objectName, long RWoptions ) {
    HRESULT _hr = raw_Write(pathString, objectName, RWoptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::Read ( _bstr_t pathString, _bstr_t objectName, long RWoptions ) {
    HRESULT _hr = raw_Read(pathString, objectName, RWoptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::Serialize ( BSTR * stream, _bstr_t objectName, long RWoptions ) {
    HRESULT _hr = raw_Serialize(stream, objectName, RWoptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::Unserialize ( _bstr_t stream, _bstr_t objectName, long RWoptions ) {
    HRESULT _hr = raw_Unserialize(stream, objectName, RWoptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr PropertyObject::EvaluateEx ( _bstr_t exprString, long EvaluationOptions ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_EvaluateEx(exprString, EvaluationOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t PropertyObject::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObject::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObject::GetComment ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Comment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObject::PutComment ( _bstr_t val ) {
    HRESULT _hr = put_Comment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObject::ValidateNewName ( _bstr_t newName, VARIANT_BOOL allowDuplicates, VARIANT_BOOL * isValid ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ValidateNewName(newName, allowDuplicates, isValid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long PropertyObject::DisplayPropertiesDialog ( _bstr_t dlgTitle, struct PropertyObjectFile * file, long dlgOptions ) {
    long _result = 0;
    HRESULT _hr = raw_DisplayPropertiesDialog(dlgTitle, file, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr PropertyObject::GetParent ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long PropertyObject::GetSubPropertyIndex ( _bstr_t lookupString, long options, _bstr_t propName ) {
    long _result = 0;
    HRESULT _hr = raw_GetSubPropertyIndex(lookupString, options, propName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetSubPropertyIndex ( _bstr_t lookupString, long options, _bstr_t propName, long index ) {
    HRESULT _hr = raw_SetSubPropertyIndex(lookupString, options, propName, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObject::GetIsRootTypeDefinition ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRootTypeDefinition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::GetCanAddSubProperty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanAddSubProperty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::InsertSubProperty ( _bstr_t lookupString, long options, long index, struct PropertyObject * subProperty ) {
    HRESULT _hr = raw_InsertSubProperty(lookupString, options, index, subProperty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetTypeDisplayString ( _bstr_t lookupString, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTypeDisplayString(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t PropertyObject::GetFormattedValue ( _bstr_t lookupString, long options, _bstr_t formatString, VARIANT_BOOL useValueFormatIfDefined, _bstr_t separator ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetFormattedValue(lookupString, options, formatString, useValueFormatIfDefined, separator, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long PropertyObject::GetNumElements ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumElements(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetNumElements ( long numElements, long options ) {
    HRESULT _hr = raw_SetNumElements(numElements, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::DeleteElements ( long arrayOffset, long numElements, long options ) {
    HRESULT _hr = raw_DeleteElements(arrayOffset, numElements, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double PropertyObject::GetValNumberByOffset ( long arrayOffset, long options ) {
    double _result = 0;
    HRESULT _hr = raw_GetValNumberByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetValNumberByOffset ( long arrayOffset, long options, double newValue ) {
    HRESULT _hr = raw_SetValNumberByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObject::GetValBooleanByOffset ( long arrayOffset, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetValBooleanByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetValBooleanByOffset ( long arrayOffset, long options, VARIANT_BOOL newValue ) {
    HRESULT _hr = raw_SetValBooleanByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetValStringByOffset ( long arrayOffset, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetValStringByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT PropertyObject::SetValStringByOffset ( long arrayOffset, long options, _bstr_t newValue ) {
    HRESULT _hr = raw_SetValStringByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr PropertyObject::GetPropertyObjectByOffset ( long arrayOffset, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetPropertyObjectByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT PropertyObject::SetPropertyObjectByOffset ( long arrayOffset, long options, struct PropertyObject * newValue ) {
    HRESULT _hr = raw_SetPropertyObjectByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t PropertyObject::GetValVariantByOffset ( long arrayOffset, long options ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValVariantByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT PropertyObject::SetValVariantByOffset ( long arrayOffset, long options, const _variant_t & newValue ) {
    HRESULT _hr = raw_SetValVariantByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IDispatchPtr PropertyObject::GetValIDispatchByOffset ( long arrayOffset, long options ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_GetValIDispatchByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

HRESULT PropertyObject::SetValIDispatchByOffset ( long arrayOffset, long options, IDispatch * newValue ) {
    HRESULT _hr = raw_SetValIDispatchByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IUnknownPtr PropertyObject::GetValInterfaceByOffset ( long arrayOffset, long options ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_GetValInterfaceByOffset(arrayOffset, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT PropertyObject::SetValInterfaceByOffset ( long arrayOffset, long options, IUnknown * newValue ) {
    HRESULT _hr = raw_SetValInterfaceByOffset(arrayOffset, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long PropertyObject::GetStructureChangeCount ( _bstr_t lookupString, long options ) {
    long _result = 0;
    HRESULT _hr = raw_GetStructureChangeCount(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long PropertyObject::GetInstanceDefaultFlags ( _bstr_t lookupString, long options ) {
    long _result = 0;
    HRESULT _hr = raw_GetInstanceDefaultFlags(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetInstanceDefaultFlags ( _bstr_t lookupString, long options, long Flags ) {
    HRESULT _hr = raw_SetInstanceDefaultFlags(lookupString, options, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObject::GetIsTypeDefinition ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTypeDefinition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::ContainsTypeInstance ( _bstr_t lookupString, long options, _bstr_t typeNameParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ContainsTypeInstance(lookupString, options, typeNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum TypeCategories PropertyObject::GetTypeCategory ( ) {
    enum TypeCategories _result;
    HRESULT _hr = get_TypeCategory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::IsEqualTo ( struct PropertyObject * objectToCompare, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsEqualTo(objectToCompare, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::IsAliasObject ( _bstr_t lookupString, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsAliasObject(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t PropertyObject::GetLocation ( struct PropertyObject * topObject ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetLocation(topObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long PropertyObject::DisplayFlagsDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    long _result = 0;
    HRESULT _hr = raw_DisplayFlagsDialog(dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::DisplayArrayBoundsDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayArrayBoundsDialog(dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::ReadEx ( _bstr_t pathString, _bstr_t objectName, long RWoptions, enum TypeConflictHandlerTypes handlerType ) {
    HRESULT _hr = raw_ReadEx(pathString, objectName, RWoptions, handlerType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObject::UnserializeEx ( _bstr_t stream, _bstr_t objectName, long RWoptions, enum TypeConflictHandlerTypes handlerType ) {
    HRESULT _hr = raw_UnserializeEx(stream, objectName, RWoptions, handlerType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetTypeVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObject::PutTypeVersion ( _bstr_t val ) {
    HRESULT _hr = put_TypeVersion(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long PropertyObject::GetTypeFlags ( _bstr_t lookupString, long options ) {
    long _result = 0;
    HRESULT _hr = raw_GetTypeFlags(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetTypeFlags ( _bstr_t lookupString, long options, long Flags ) {
    HRESULT _hr = raw_SetTypeFlags(lookupString, options, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long PropertyObject::GetInstanceOverrideFlags ( _bstr_t lookupString, long options ) {
    long _result = 0;
    HRESULT _hr = raw_GetInstanceOverrideFlags(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetInstanceOverrideFlags ( _bstr_t lookupString, long options, long Flags ) {
    HRESULT _hr = raw_SetInstanceOverrideFlags(lookupString, options, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetNumericFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_NumericFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObject::PutNumericFormat ( _bstr_t val ) {
    HRESULT _hr = put_NumericFormat(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr PropertyObject::GetArrayElementPrototype ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_ArrayElementPrototype(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void PropertyObject::PutArrayElementPrototype ( struct PropertyObject * val ) {
    HRESULT _hr = put_ArrayElementPrototype(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void PropertyObject::PutRefArrayElementPrototype ( struct PropertyObject * val ) {
    HRESULT _hr = putref_ArrayElementPrototype(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObject::ValidateNewSubPropertyName ( _bstr_t newName, VARIANT_BOOL allowDuplicates, VARIANT_BOOL * isValid ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ValidateNewSubPropertyName(newName, allowDuplicates, isValid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t PropertyObject::ValidateNewElementName ( _bstr_t newName, VARIANT_BOOL allowDuplicates, VARIANT_BOOL * isValid ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ValidateNewElementName(newName, allowDuplicates, isValid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long PropertyObject::GetInternalPtr ( _bstr_t engineId ) {
    long _result = 0;
    HRESULT _hr = raw_GetInternalPtr(engineId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t PropertyObject::GetXML ( long GenerationOptions, long InitialIndentation, _bstr_t DefaultName, _bstr_t formatString ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetXML(GenerationOptions, InitialIndentation, DefaultName, formatString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SearchResultsPtr PropertyObject::Search ( _bstr_t lookupString, _bstr_t searchString, long SearchOptions, long filterOptions, long elementsToSearch, SAFEARRAY * limitToAdapters, SAFEARRAY * limitToNamedProps, SAFEARRAY * limitToPropsOfNamedTypes, SAFEARRAY * subpropLookupStringsToExclude ) {
    struct SearchResults * _result = 0;
    HRESULT _hr = raw_Search(lookupString, searchString, SearchOptions, filterOptions, elementsToSearch, limitToAdapters, limitToNamedProps, limitToPropsOfNamedTypes, subpropLookupStringsToExclude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SearchResultsPtr(_result, false);
}

_bstr_t PropertyObject::GetTypeLastModified ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeLastModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT PropertyObject::GetDisplayNames ( _bstr_t lookupString, long options, BSTR * propDisplayName, BSTR * valueDisplayName ) {
    HRESULT _hr = raw_GetDisplayNames(lookupString, options, propDisplayName, valueDisplayName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObject::GetTypeMinimumTestStandVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeMinimumTestStandVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObject::PutTypeMinimumTestStandVersion ( _bstr_t val ) {
    HRESULT _hr = put_TypeMinimumTestStandVersion(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT PropertyObject::SetXML ( _bstr_t xmlStream, long reserved1, enum TypeConflictHandlerTypes reserved2 ) {
    HRESULT _hr = raw_SetXML(xmlStream, reserved1, reserved2);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * PropertyObject::GetValBinary ( _bstr_t lookupString, long options ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetValBinary(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObject::SetValBinary ( _bstr_t lookupString, long options, SAFEARRAY * newValue ) {
    HRESULT _hr = raw_SetValBinary(lookupString, options, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr PropertyObject::GetNthSubProperty ( _bstr_t lookupString, long index, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetNthSubProperty(lookupString, index, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT PropertyObject::DeleteNthSubProperty ( _bstr_t lookupString, long index, long options ) {
    HRESULT _hr = raw_DeleteNthSubProperty(lookupString, index, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectTypePtr PropertyObject::GetType ( ) {
    struct PropertyObjectType * _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectTypePtr(_result, false);
}

VARIANT_BOOL PropertyObject::GetIsModifiedType ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsModifiedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void PropertyObject::PutIsModifiedType ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IsModifiedType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr PropertyObject::GetAttributes ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL PropertyObject::GetHasAttributes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObject::DisplayAttributesDialog ( _bstr_t dlgTitle, struct PropertyObjectFile * file, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayAttributesDialog(dlgTitle, file, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ReportSectionPtr PropertyObject::CreateReportSection ( long GenerationOptions, long InitialIndentation, _bstr_t DefaultName, _bstr_t formatString, _bstr_t Format ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = raw_CreateReportSection(GenerationOptions, InitialIndentation, DefaultName, formatString, Format, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

//
// interface TypeUsageList wrapper method implementations
//

long TypeUsageList::GetNumTypes ( ) {
    long _result = 0;
    HRESULT _hr = get_NumTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr TypeUsageList::GetTypeDefinition ( long index ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetTypeDefinition(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long TypeUsageList::GetTypeIndex ( _bstr_t typeNameParam ) {
    long _result = 0;
    HRESULT _hr = raw_GetTypeIndex(typeNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT TypeUsageList::InsertType ( struct PropertyObject * typeToInsert, long index, enum TypeCategories typeCategoryParam ) {
    HRESULT _hr = raw_InsertType(typeToInsert, index, typeCategoryParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr TypeUsageList::RemoveType ( long index ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_RemoveType(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT TypeUsageList::SetIsTypeAttachedToFile ( long index, VARIANT_BOOL store ) {
    HRESULT _hr = raw_SetIsTypeAttachedToFile(index, store);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL TypeUsageList::GetIsTypeAttachedToFile ( long index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetIsTypeAttachedToFile(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL TypeUsageList::AddUsedTypes ( struct PropertyObject * propObject ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddUsedTypes(propObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT TypeUsageList::MoveType ( long index, long newIndex ) {
    HRESULT _hr = raw_MoveType(index, newIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long TypeUsageList::GetChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t TypeUsageList::ValidateNewTypeName ( _bstr_t newName, VARIANT_BOOL allowDuplicates, VARIANT_BOOL * isValid ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ValidateNewTypeName(newName, allowDuplicates, isValid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL TypeUsageList::Union ( struct TypeUsageList * unionTypeUsageList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Union(unionTypeUsageList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface PropertyObjectFile wrapper method implementations
//

TypeUsageListPtr PropertyObjectFile::GetTypeUsageList ( ) {
    struct TypeUsageList * _result = 0;
    HRESULT _hr = get_TypeUsageList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TypeUsageListPtr(_result, false);
}

HRESULT PropertyObjectFile::IncChangeCount ( ) {
    HRESULT _hr = raw_IncChangeCount();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL PropertyObjectFile::GetIsModified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObjectFile::ReadFile ( enum TypeConflictHandlerTypes handlerType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ReadFile(handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObjectFile::WriteFile ( enum WriteFileFormat writeFormat ) {
    HRESULT _hr = raw_WriteFile(writeFormat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr PropertyObjectFile::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL PropertyObjectFile::HandleTypeConflicts ( enum TypeConflictHandlerTypes handlerType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HandleTypeConflicts(handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObjectFile::SaveFileIfModified ( VARIANT_BOOL prompt ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SaveFileIfModified(prompt, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long PropertyObjectFile::GetChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t PropertyObjectFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutPath ( _bstr_t val ) {
    HRESULT _hr = put_Path(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_DisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr PropertyObjectFile::GetData ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Data(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void PropertyObjectFile::PutData ( struct PropertyObject * val ) {
    HRESULT _hr = put_Data(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void PropertyObjectFile::PutRefData ( struct PropertyObject * val ) {
    HRESULT _hr = putref_Data(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetContentType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ContentType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutContentType ( _bstr_t val ) {
    HRESULT _hr = put_ContentType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetFileTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileTypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutFileTypeDescription ( _bstr_t val ) {
    HRESULT _hr = put_FileTypeDescription(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetFileSection ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileSection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutFileSection ( _bstr_t val ) {
    HRESULT _hr = put_FileSection(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long PropertyObjectFile::GetOpenStatus ( ) {
    long _result = 0;
    HRESULT _hr = get_OpenStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void PropertyObjectFile::PutOpenStatus ( long val ) {
    HRESULT _hr = put_OpenStatus(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetEditPrivilege ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EditPrivilege(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutEditPrivilege ( _bstr_t val ) {
    HRESULT _hr = put_EditPrivilege(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long PropertyObjectFile::GetIsDiskFileModified ( ) {
    long _result = 0;
    HRESULT _hr = get_IsDiskFileModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum PropertyObjectFileTypes PropertyObjectFile::GetFileType ( ) {
    enum PropertyObjectFileTypes _result;
    HRESULT _hr = get_FileType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL PropertyObjectFile::GetIsDiskFileReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDiskFileReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long PropertyObjectFile::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObjectFile::CheckForModifiedTypes ( _bstr_t dlgTitle, _bstr_t okButtonText, long options, enum TypeVersionAutoIncrement versionIncOption, VARIANT_BOOL * operationCanceled, VARIANT_BOOL * foundModifiedTypes ) {
    HRESULT _hr = raw_CheckForModifiedTypes(dlgTitle, okButtonText, options, versionIncOption, operationCanceled, foundModifiedTypes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t PropertyObjectFile::GetComment ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Comment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutComment ( _bstr_t val ) {
    HRESULT _hr = put_Comment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t PropertyObjectFile::GetVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void PropertyObjectFile::PutVersion ( _bstr_t val ) {
    HRESULT _hr = put_Version(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL PropertyObjectFile::GetIsModifiedByUser ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsModifiedByUser(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr PropertyObjectFile::GetRequirements ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Requirements(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long PropertyObjectFile::GetProtection ( ) {
    long _result = 0;
    HRESULT _hr = get_Protection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void PropertyObjectFile::PutProtection ( long val ) {
    HRESULT _hr = put_Protection(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL PropertyObjectFile::GetLocked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Locked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT PropertyObjectFile::Lock ( const _variant_t & passwordString ) {
    HRESULT _hr = raw_Lock(passwordString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT PropertyObjectFile::Unlock ( _bstr_t passwordString ) {
    HRESULT _hr = raw_Unlock(passwordString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

void PropertyObjectFile::PutChangeCount ( long val ) {
    HRESULT _hr = put_ChangeCount(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FileWritingFormats PropertyObjectFile::GetFileWritingFormat ( ) {
    enum FileWritingFormats _result;
    HRESULT _hr = get_FileWritingFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void PropertyObjectFile::PutFileWritingFormat ( enum FileWritingFormats val ) {
    HRESULT _hr = put_FileWritingFormat(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Adapter wrapper method implementations
//

HRESULT Adapter::Configure ( ) {
    HRESULT _hr = raw_Configure();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr Adapter::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL Adapter::GetIsConfigurable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConfigurable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Adapter::GetKeyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_KeyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t Adapter::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IPictureDisp * Adapter::GetSmallIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_SmallIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPictureDisp * Adapter::GetLargeIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_LargeIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Adapter::GetSmallIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SmallIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Adapter::GetLargeIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_LargeIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Adapter::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Adapter::GetHidden ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Hidden(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Adapter::PutHidden ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Hidden(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Adapter::GetShowArgsInStepDescription ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowArgsInStepDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Adapter::PutShowArgsInStepDescription ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowArgsInStepDescription(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface User wrapper method implementations
//

VARIANT_BOOL User::ValidatePassword ( _bstr_t passwordString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ValidatePassword(passwordString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL User::HasPrivilege ( _bstr_t privilegeName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasPrivilege(privilegeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr User::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t User::GetLoginName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoginName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void User::PutLoginName ( _bstr_t val ) {
    HRESULT _hr = put_LoginName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t User::GetPassword ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Password(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void User::PutPassword ( _bstr_t val ) {
    HRESULT _hr = put_Password(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t User::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void User::PutFullName ( _bstr_t val ) {
    HRESULT _hr = put_FullName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr User::GetPrivileges ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Privileges(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr User::GetMembers ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Members(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

//
// interface UsersFile wrapper method implementations
//

PropertyObjectPtr UsersFile::GetUserList ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_UserList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void UsersFile::PutUserList ( struct PropertyObject * val ) {
    HRESULT _hr = put_UserList(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void UsersFile::PutRefUserList ( struct PropertyObject * val ) {
    HRESULT _hr = putref_UserList(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr UsersFile::GetUserProfileList ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_UserProfileList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void UsersFile::PutUserProfileList ( struct PropertyObject * val ) {
    HRESULT _hr = put_UserProfileList(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT UsersFile::ReloadFromDisk ( ) {
    HRESULT _hr = raw_ReloadFromDisk();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectFilePtr UsersFile::AsPropertyObjectFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = raw_AsPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

PropertyObjectPtr UsersFile::GetUserGroupList ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_UserGroupList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void UsersFile::PutUserGroupList ( struct PropertyObject * val ) {
    HRESULT _hr = put_UserGroupList(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface WorkspaceObject wrapper method implementations
//

WorkspaceObjectPtr WorkspaceObject::NewFolder ( _bstr_t Name ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_NewFolder(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

WorkspaceObjectPtr WorkspaceObject::NewFile ( _bstr_t Path ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_NewFile(Path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

HRESULT WorkspaceObject::InsertObject ( struct WorkspaceObject * obj, long index ) {
    HRESULT _hr = raw_InsertObject(obj, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t WorkspaceObject::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WorkspaceObject::PutPath ( _bstr_t val ) {
    HRESULT _hr = put_Path(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WorkspaceObject::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WorkspaceObject::PutDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_DisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL WorkspaceObject::GetIsCodeModule ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCodeModule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t WorkspaceObject::GetCodeModuleSeqFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CodeModuleSeqFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WorkspaceObject::PutCodeModuleSeqFilePath ( _bstr_t val ) {
    HRESULT _hr = put_CodeModuleSeqFilePath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum WorkspaceObjectTypes WorkspaceObject::GetObjectType ( ) {
    enum WorkspaceObjectTypes _result;
    HRESULT _hr = get_ObjectType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long WorkspaceObject::GetSourceControlStatus ( ) {
    long _result = 0;
    HRESULT _hr = get_SourceControlStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL WorkspaceObject::DoSourceControlCommand ( enum SourceControlCommands scCommand, VARIANT_BOOL * modifiedObject, long options, const _variant_t & itemList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DoSourceControlCommand(scCommand, modifiedObject, options, itemList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr WorkspaceObject::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t WorkspaceObject::GetAbsolutePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetAbsolutePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

WorkspaceObjectPtr WorkspaceObject::RemoveObject ( long index ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_RemoveObject(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

PropertyObjectFilePtr WorkspaceObject::GetProjectFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_ProjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

SAFEARRAY * WorkspaceObject::InsertCodeModules ( const _variant_t & itemList ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_InsertCodeModules(itemList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT WorkspaceObject::UpdateStatus ( long options ) {
    HRESULT _hr = raw_UpdateStatus(options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL WorkspaceObject::GetFileExists ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FileExists(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t WorkspaceObject::GetLastSourceControlMessages ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LastSourceControlMessages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL WorkspaceObject::CanDoSourceControlCommand ( enum SourceControlCommands scCommand, long options, const _variant_t & itemList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanDoSourceControlCommand(scCommand, options, itemList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

WorkspaceObjectPtr WorkspaceObject::GetParentContainer ( ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_GetParentContainer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

long WorkspaceObject::GetNumContainedObjects ( ) {
    long _result = 0;
    HRESULT _hr = get_NumContainedObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

WorkspaceObjectPtr WorkspaceObject::GetContainedObject ( long index ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_GetContainedObject(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

//
// interface WorkspaceFile wrapper method implementations
//

WorkspaceObjectPtr WorkspaceFile::GetRootWorkspaceObject ( ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = get_RootWorkspaceObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

VARIANT_BOOL WorkspaceFile::GetIsConnectedToSCProvider ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConnectedToSCProvider(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t WorkspaceFile::GetProviderName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProviderName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WorkspaceFile::PutProviderName ( _bstr_t val ) {
    HRESULT _hr = put_ProviderName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectFilePtr WorkspaceFile::AsPropertyObjectFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = raw_AsPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

WorkspaceObjectPtr WorkspaceFile::FindWorkspaceObject ( _bstr_t fullPath ) {
    struct WorkspaceObject * _result = 0;
    HRESULT _hr = raw_FindWorkspaceObject(fullPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceObjectPtr(_result, false);
}

HRESULT WorkspaceFile::RunSourceControlProvider ( ) {
    HRESULT _hr = raw_RunSourceControlProvider();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL WorkspaceFile::DisplayAddFileToWorkspaceDialog ( struct WorkspaceObject * selectedProject, _bstr_t fullPath ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayAddFileToWorkspaceDialog(selectedProject, fullPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectFilePtr WorkspaceFile::GetOptionsFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_OptionsFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

VARIANT_BOOL WorkspaceFile::SaveWorkspaceAndProjectFiles ( long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SaveWorkspaceAndProjectFiles(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Expression wrapper method implementations
//

_bstr_t Expression::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Expression::PutText ( _bstr_t val ) {
    HRESULT _hr = put_Text(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Expression::GetNumTokens ( ) {
    long _result = 0;
    HRESULT _hr = get_NumTokens(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Expression::GetToken ( long tokenIndex, enum TokenCode * TokenCode, long * charIndex, long * numChars, BSTR * tokenText ) {
    HRESULT _hr = raw_GetToken(tokenIndex, TokenCode, charIndex, numChars, tokenText);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long Expression::Tokenize ( long options, long initialParseState ) {
    long _result = 0;
    HRESULT _hr = raw_Tokenize(options, initialParseState, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Expression::Validate ( struct PropertyObject * evaluationContext, VARIANT_BOOL checkSyntaxOnly, long EvaluationOptions, BSTR * errMsg, long * errorCharIndex, long * errorEndCharIndex ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Validate(evaluationContext, checkSyntaxOnly, EvaluationOptions, errMsg, errorCharIndex, errorEndCharIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Expression::Evaluate ( struct PropertyObject * evaluationContext, long EvaluationOptions ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_Evaluate(evaluationContext, EvaluationOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

enum TSError Expression::ValidateEvaluationType ( struct EvaluationTypes * validEvaluationTypes, SAFEARRAY * additionalConstants, struct PropertyObject * evaluationContext, long EvaluationOptions, BSTR * errMsg, long * errorStartIndex, long * errorEndIndex ) {
    enum TSError _result;
    HRESULT _hr = raw_ValidateEvaluationType(validEvaluationTypes, additionalConstants, evaluationContext, EvaluationOptions, errMsg, errorStartIndex, errorEndIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Expression::GetConstantValue ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetConstantValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

//
// interface ReportSection wrapper method implementations
//

ReportSectionsPtr ReportSection::GetReportSubsections ( ) {
    struct ReportSections * _result = 0;
    HRESULT _hr = get_ReportSubsections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionsPtr(_result, false);
}

void ReportSection::PutReportSubsections ( struct ReportSections * val ) {
    HRESULT _hr = put_ReportSubsections(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ReportSection::GetBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Body(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ReportSection::PutBody ( _bstr_t val ) {
    HRESULT _hr = put_Body(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ReportSection::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long ReportSection::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t ReportSection::GetHeader ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Header(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ReportSection::PutHeader ( _bstr_t val ) {
    HRESULT _hr = put_Header(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ReportSection::GetFooter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Footer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ReportSection::PutFooter ( _bstr_t val ) {
    HRESULT _hr = put_Footer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ReportSection::GetAllText ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetAllText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ReportSections wrapper method implementations
//

ReportSectionPtr ReportSections::GetItem ( const _variant_t & index ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

IUnknownPtr ReportSections::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long ReportSections::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ReportSectionPtr ReportSections::Insert ( long index, _bstr_t Header, _bstr_t Body, _bstr_t Footer ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = raw_Insert(index, Header, Body, Footer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

ReportSectionPtr ReportSections::Remove ( long index ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = raw_Remove(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

HRESULT ReportSections::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ReportSections::InsertExisting ( struct ReportSection * val, long index ) {
    HRESULT _hr = raw_InsertExisting(val, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface Report wrapper method implementations
//

long Report::Append ( _bstr_t stringToAppend ) {
    long _result = 0;
    HRESULT _hr = raw_Append(stringToAppend, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Report::Reset ( _bstr_t newValue ) {
    long _result = 0;
    HRESULT _hr = raw_Reset(newValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Report::Save ( _bstr_t pathString, VARIANT_BOOL appendIfAlreadyExists, enum ReportConversion linefeedConversion ) {
    HRESULT _hr = raw_Save(pathString, appendIfAlreadyExists, linefeedConversion);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Report::Load ( _bstr_t pathString, enum ReportConversion linefeedConversion ) {
    HRESULT _hr = raw_Load(pathString, linefeedConversion);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Report::LaunchViewer ( enum ReportConversion linefeedConversion ) {
    HRESULT _hr = raw_LaunchViewer(linefeedConversion);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Report::GetTempFile ( enum ReportConversion linefeedConversion, const _variant_t & extensionString ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTempFile(linefeedConversion, extensionString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

PropertyObjectPtr Report::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t Report::GetAll ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long Report::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Report::GetLocation ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Report::PutLocation ( _bstr_t val ) {
    HRESULT _hr = put_Location(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Report::GetFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Format(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Report::PutFormat ( _bstr_t val ) {
    HRESULT _hr = put_Format(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Report::GetSection ( long oldestIndex, long latestIndex ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetSection(oldestIndex, latestIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long Report::GetLatestAppendIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_LatestAppendIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Report::GetResetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ResetCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Report::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Report::GetStyleSheetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StyleSheetPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Report::PutStyleSheetPath ( _bstr_t val ) {
    HRESULT _hr = put_StyleSheetPath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Report::GetTempFileDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TempFileDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Report::PutTempFileDirectory ( _bstr_t val ) {
    HRESULT _hr = put_TempFileDirectory(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ReportSectionPtr Report::GetReportSection ( ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = get_ReportSection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

void Report::PutReportSection ( struct ReportSection * val ) {
    HRESULT _hr = put_ReportSection(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ReportSectionPtr Report::NewReportSection ( ) {
    struct ReportSection * _result = 0;
    HRESULT _hr = raw_NewReportSection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportSectionPtr(_result, false);
}

VARIANT_BOOL Report::GetSuspendReportRefresh ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SuspendReportRefresh(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Report::PutSuspendReportRefresh ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SuspendReportRefresh(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IEngine wrapper method implementations
//

HRESULT IEngine::ShutDown ( VARIANT_BOOL final ) {
    HRESULT _hr = raw_ShutDown(final);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequenceFilePtr IEngine::GetSequenceFile ( _bstr_t SequenceFilePath, long getSeqFileFlags ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetSequenceFile(SequenceFilePath, getSeqFileFlags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

SequenceFilePtr IEngine::NewSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_NewSequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

HRESULT IEngine::ReleaseSequenceFile ( struct SequenceFile * sequenceFileToRelease ) {
    HRESULT _hr = raw_ReleaseSequenceFile(sequenceFileToRelease);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequencePtr IEngine::NewSequence ( ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_NewSequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

StepPtr IEngine::NewStep ( _bstr_t adapterKeyNameVal, _bstr_t stepTypeName ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_NewStep(adapterKeyNameVal, stepTypeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

UserPtr IEngine::NewUser ( struct User * userProfile ) {
    struct User * _result = 0;
    HRESULT _hr = raw_NewUser(userProfile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UserPtr(_result, false);
}

VARIANT_BOOL IEngine::UserNameExists ( _bstr_t LoginName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserNameExists(LoginName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

UserPtr IEngine::GetUser ( _bstr_t LoginName ) {
    struct User * _result = 0;
    HRESULT _hr = raw_GetUser(LoginName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UserPtr(_result, false);
}

VARIANT_BOOL IEngine::CurrentUserHasPrivilege ( _bstr_t privilegeName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CurrentUserHasPrivilege(privilegeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

UserPtr IEngine::GetUserProfile ( _bstr_t userProfileName ) {
    struct User * _result = 0;
    HRESULT _hr = raw_GetUserProfile(userProfileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UserPtr(_result, false);
}

AdapterPtr IEngine::GetAdapter ( long adapterIndex ) {
    struct Adapter * _result = 0;
    HRESULT _hr = raw_GetAdapter(adapterIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdapterPtr(_result, false);
}

ExecutionPtr IEngine::NewExecution ( struct SequenceFile * sequenceFileParam, _bstr_t sequenceNameParam, struct SequenceFile * processModelParam, VARIANT_BOOL breakAtFirstStep, long executionTypeMaskParam, const _variant_t & sequenceArgsParam, const _variant_t & editArgsParam, const _variant_t & InteractiveArgsParam ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_NewExecution(sequenceFileParam, sequenceNameParam, processModelParam, breakAtFirstStep, executionTypeMaskParam, sequenceArgsParam, editArgsParam, InteractiveArgsParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

ExecutionPtr IEngine::CallFrontEndCallback ( _bstr_t sequenceNameParam, struct PropertyObject * argumentList ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_CallFrontEndCallback(sequenceNameParam, argumentList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

HRESULT IEngine::AbortAll ( ) {
    HRESULT _hr = raw_AbortAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::BreakAll ( ) {
    HRESULT _hr = raw_BreakAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::TerminateAll ( ) {
    HRESULT _hr = raw_TerminateAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

RExecutorPtr IEngine::GetRemoteExecutorInterface ( long adapterIndex ) {
    struct RExecutor * _result = 0;
    HRESULT _hr = raw_GetRemoteExecutorInterface(adapterIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RExecutorPtr(_result, false);
}

InteractiveArgsPtr IEngine::NewInteractiveArgs ( ) {
    struct InteractiveArgs * _result = 0;
    HRESULT _hr = raw_NewInteractiveArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InteractiveArgsPtr(_result, false);
}

EditArgsPtr IEngine::NewEditArgs ( ) {
    struct EditArgs * _result = 0;
    HRESULT _hr = raw_NewEditArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EditArgsPtr(_result, false);
}

PropertyObjectPtr IEngine::NewPropertyObject ( enum PropertyValueTypes ValueType, VARIANT_BOOL asArray, _bstr_t typeNameParam, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_NewPropertyObject(ValueType, asArray, typeNameParam, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT IEngine::RegisterUIMessageCallback ( long callbackFuncAddr ) {
    HRESULT _hr = raw_RegisterUIMessageCallback(callbackFuncAddr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

UIMessagePtr IEngine::GetUIMessage ( ) {
    struct UIMessage * _result = 0;
    HRESULT _hr = raw_GetUIMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UIMessagePtr(_result, false);
}

VARIANT_BOOL IEngine::DisplayLoginDialog ( _bstr_t dlgTitle, _bstr_t initialLoginName, _bstr_t initialPassword, VARIANT_BOOL modalToAppMainWind, struct User * * userObject ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayLoginDialog(dlgTitle, initialLoginName, initialPassword, modalToAppMainWind, userObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayEditUserDialog ( _bstr_t dlgTitle, struct User * userObject, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayEditUserDialog(dlgTitle, userObject, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayNewUserDialog ( _bstr_t dlgTitle, VARIANT_BOOL modalToAppMainWind, struct User * * userObject ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayNewUserDialog(dlgTitle, modalToAppMainWind, userObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplaySearchDirDialog ( _bstr_t dlgTitle, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplaySearchDirDialog(dlgTitle, readOnly, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayOptionsDialog ( _bstr_t dlgTitle, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayOptionsDialog(dlgTitle, readOnly, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::DisplayRunTimeErrorDialog ( _bstr_t dlgTitle, _bstr_t errorMessage, VARIANT_BOOL inCleanupStepGroup, VARIANT_BOOL modalToAppMainWind, VARIANT_BOOL * displayOnNextError, VARIANT_BOOL * suspendExecution, enum RTEOptions * runTimeErrorAction ) {
    HRESULT _hr = raw_DisplayRunTimeErrorDialog(dlgTitle, errorMessage, inCleanupStepGroup, modalToAppMainWind, displayOnNextError, suspendExecution, runTimeErrorAction);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayOpenFileDialog ( _bstr_t dlgTitle, _bstr_t okButtonText, _bstr_t initialPath, VARIANT_BOOL modalToAppMainWind, BSTR * selectedPath, BSTR * absolutePath, long openFileDialogFlags, _bstr_t defaultExtension, long win32Flags, _bstr_t fileFilter, const _variant_t & currentSequenceFile ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayOpenFileDialog(dlgTitle, okButtonText, initialPath, modalToAppMainWind, selectedPath, absolutePath, openFileDialogFlags, defaultExtension, win32Flags, fileFilter, currentSequenceFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayStepPropDialog ( _bstr_t dlgTitle, struct Step * Step, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind, VARIANT_BOOL showViewContentsBtn, VARIANT_BOOL * viewContents, VARIANT_BOOL * modifiedStep ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayStepPropDialog(dlgTitle, Step, readOnly, modalToAppMainWind, showViewContentsBtn, viewContents, modifiedStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplaySequencePropDialog ( _bstr_t dlgTitle, struct Sequence * Sequence, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind, VARIANT_BOOL showViewContentsBtn, VARIANT_BOOL * viewContents ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplaySequencePropDialog(dlgTitle, Sequence, readOnly, modalToAppMainWind, showViewContentsBtn, viewContents, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplaySeqFilePropDialog ( _bstr_t dlgTitle, struct SequenceFile * sequenceFileParam, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind, VARIANT_BOOL showViewContentsBtn, VARIANT_BOOL * viewContents ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplaySeqFilePropDialog(dlgTitle, sequenceFileParam, readOnly, modalToAppMainWind, showViewContentsBtn, viewContents, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayPreconditionDialog ( _bstr_t dlgTitle, struct Sequence * Sequence, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind, const _variant_t & initialStep ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayPreconditionDialog(dlgTitle, Sequence, readOnly, modalToAppMainWind, initialStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayBrowseExprDialog ( _bstr_t dlgTitle, struct SequenceContext * sequenceContextParam, _bstr_t expressionIn, long selectionStartIn, long selectionEndIn, _bstr_t initialVariableName, VARIANT_BOOL usesCRLF, VARIANT_BOOL modalToAppMainWind, BSTR * expressionOut, long * selectionStartOut, long * selectionEndOut ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayBrowseExprDialog(dlgTitle, sequenceContextParam, expressionIn, selectionStartIn, selectionEndIn, initialVariableName, usesCRLF, modalToAppMainWind, expressionOut, selectionStartOut, selectionEndOut, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayToolMenuDialog ( _bstr_t dlgTitle, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayToolMenuDialog(dlgTitle, readOnly, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayExternalViewerDialog ( _bstr_t dlgTitle, VARIANT_BOOL readOnly, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayExternalViewerDialog(dlgTitle, readOnly, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayAdapterConfigDialog ( _bstr_t dlgTitle, VARIANT_BOOL adapterSelectorReadOnly, VARIANT_BOOL adapterCfgReadOnly, VARIANT_BOOL hideAdapterSelector, VARIANT_BOOL modalToAppMainWind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayAdapterConfigDialog(dlgTitle, adapterSelectorReadOnly, adapterCfgReadOnly, hideAdapterSelector, modalToAppMainWind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayLoopOnStepsDialog ( _bstr_t dlgTitle, struct Step * selectedStep, VARIANT_BOOL modalToAppMainWnd, long * loopCountValue, BSTR * stopExpressionValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayLoopOnStepsDialog(dlgTitle, selectedStep, modalToAppMainWnd, loopCountValue, stopExpressionValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::ConstructToolMenus ( const _variant_t & editArgsParam ) {
    long _result = 0;
    HRESULT _hr = raw_ConstructToolMenus(editArgsParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetNumToolMenus ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumToolMenus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetNumToolMenuItems ( long menuIndex ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumToolMenuItems(menuIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::GetToolMenuItemInfo ( long menuIndex, long itemIndex, BSTR * itemText, long * subMenuIndex, VARIANT_BOOL * enabled, long * uniqueItemID ) {
    HRESULT _hr = raw_GetToolMenuItemInfo(menuIndex, itemIndex, itemText, subMenuIndex, enabled, uniqueItemID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::GetToolMenuItemInfoWithID ( long uniqueItemID, BSTR * itemText, long * subMenuIndex, VARIANT_BOOL * enabled ) {
    HRESULT _hr = raw_GetToolMenuItemInfoWithID(uniqueItemID, itemText, subMenuIndex, enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::InvokeToolMenuItem ( long menuIndex, long itemIndex ) {
    HRESULT _hr = raw_InvokeToolMenuItem(menuIndex, itemIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::InvokeToolMenuItemWithID ( long uniqueItemID ) {
    HRESULT _hr = raw_InvokeToolMenuItemWithID(uniqueItemID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::EvalToolMenuItemExprs ( const _variant_t & editArgsParam ) {
    HRESULT _hr = raw_EvalToolMenuItemExprs(editArgsParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::FindFile ( _bstr_t fileToFind, BSTR * absolutePath, VARIANT_BOOL * userCancelled, enum FindFilePromptOptions promptOption, enum FindFileSearchListOptions srchListOption, VARIANT_BOOL isCommand, const _variant_t & currentSequenceFile ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindFile(fileToFind, absolutePath, userCancelled, promptOption, srchListOption, isCommand, currentSequenceFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::FindPath ( _bstr_t pathToFind, BSTR * absolutePath, enum FindPathStatusValues * statusFlag, const _variant_t & currentSequenceFile ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindPath(pathToFind, absolutePath, statusFlag, currentSequenceFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::CreateTempFile ( _bstr_t baseName, _bstr_t extension, _bstr_t directory ) {
    BSTR _result = 0;
    HRESULT _hr = raw_CreateTempFile(baseName, extension, directory, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IEngine::CheckExprSyntax ( _bstr_t expressionStr, BSTR * errorDescription, long * startErrPos, long * endErrPos ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CheckExprSyntax(expressionStr, errorDescription, startErrPos, endErrPos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetErrorString ( enum TSError errorCode, BSTR * errorString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetErrorString(errorCode, errorString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::GetResourceString ( _bstr_t section, _bstr_t symbol, const _variant_t & defaultString, VARIANT * found ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetResourceString(section, symbol, defaultString, found, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IEngine::LaunchExternalViewer ( _bstr_t FilePath ) {
    HRESULT _hr = raw_LaunchExternalViewer(FilePath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IEngine::NotifyStartOfModalDialog ( ) {
    long _result = 0;
    HRESULT _hr = raw_NotifyStartOfModalDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::NotifyEndOfModalDialog ( long modalID ) {
    HRESULT _hr = raw_NotifyEndOfModalDialog(modalID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::CommitGlobalsToDisk ( VARIANT_BOOL promptOnSaveConflicts ) {
    HRESULT _hr = raw_CommitGlobalsToDisk(promptOnSaveConflicts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::UnloadAllModules ( ) {
    HRESULT _hr = raw_UnloadAllModules();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequenceFilePtr IEngine::GetStationModelSequenceFile ( BSTR * modelDescriptionString ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetStationModelSequenceFile(modelDescriptionString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

HRESULT IEngine::ReloadGlobals ( ) {
    HRESULT _hr = raw_ReloadGlobals();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr IEngine::GetGlobals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Globals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

UserPtr IEngine::GetCurrentUser ( ) {
    struct User * _result = 0;
    HRESULT _hr = get_CurrentUser(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UserPtr(_result, false);
}

void IEngine::PutCurrentUser ( struct User * val ) {
    HRESULT _hr = put_CurrentUser(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetApplicationIsEditor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ApplicationIsEditor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutApplicationIsEditor ( VARIANT_BOOL isEditor ) {
    HRESULT _hr = put_ApplicationIsEditor(isEditor);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::GetAppMainHwnd ( ) {
    long _result = 0;
    HRESULT _hr = get_AppMainHwnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutAppMainHwnd ( long hwnd ) {
    HRESULT _hr = put_AppMainHwnd(hwnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::GetNumAdapters ( ) {
    long _result = 0;
    HRESULT _hr = get_NumAdapters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::GetDefaultAdapter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DefaultAdapter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IEngine::PutDefaultAdapter ( _bstr_t adapterKeyNameVal ) {
    HRESULT _hr = put_DefaultAdapter(adapterKeyNameVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetEnableUserPrivilegeChecking ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableUserPrivilegeChecking(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutEnableUserPrivilegeChecking ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_EnableUserPrivilegeChecking(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetAutoLoginSystemUser ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoLoginSystemUser(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutAutoLoginSystemUser ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_AutoLoginSystemUser(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::GetMajorVersion ( ) {
    long _result = 0;
    HRESULT _hr = get_MajorVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetMinorVersion ( ) {
    long _result = 0;
    HRESULT _hr = get_MinorVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetRevisionVersion ( ) {
    long _result = 0;
    HRESULT _hr = get_RevisionVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::GetVersionString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_VersionString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IEngine::GetEnableRemote ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableRemote(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutEnableRemote ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_EnableRemote(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IEngine::GetConfigDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConfigDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IEngine::GetBinDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BinDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IEngine::GetTestStandDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TestStandDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

PropertyObjectPtr IEngine::GetStepTypes ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_StepTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr IEngine::GetCustomDataTypes ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_CustomDataTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr IEngine::GetBuiltinDataTypes ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_BuiltinDataTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL IEngine::GetTracingEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TracingEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutTracingEnabled ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_TracingEnabled(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetBreakpointsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakpointsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutBreakpointsEnabled ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_BreakpointsEnabled(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetDisableResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DisableResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutDisableResults ( VARIANT_BOOL isDisabled ) {
    HRESULT _hr = put_DisableResults(isDisabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetAlwaysGotoCleanupOnFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AlwaysGotoCleanupOnFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutAlwaysGotoCleanupOnFailure ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_AlwaysGotoCleanupOnFailure(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetBreakOnRTE ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnRTE(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutBreakOnRTE ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_BreakOnRTE(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::GetExecutionMask ( ) {
    long _result = 0;
    HRESULT _hr = get_ExecutionMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutExecutionMask ( long val ) {
    HRESULT _hr = put_ExecutionMask(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetUIMessagePollingEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UIMessagePollingEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUIMessagePollingEnabled ( VARIANT_BOOL isEnabled ) {
    HRESULT _hr = put_UIMessagePollingEnabled(isEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetIsUIMessageQueueEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsUIMessageQueueEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetUIMessageDelay ( ) {
    long _result = 0;
    HRESULT _hr = get_UIMessageDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUIMessageDelay ( long millisecDelay ) {
    HRESULT _hr = put_UIMessageDelay(millisecDelay);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::GetUIMessageMinDelay ( ) {
    long _result = 0;
    HRESULT _hr = get_UIMessageMinDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUIMessageMinDelay ( long millisecDelay ) {
    HRESULT _hr = put_UIMessageMinDelay(millisecDelay);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IEngine::PutIsRemote ( VARIANT_BOOL isRemoteParam ) {
    HRESULT _hr = put_IsRemote(isRemoteParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetIsRemote ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRemote(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::LocalizeExpression ( _bstr_t expressionString, enum DecimalPointLocalizationOptions decimalPointOption ) {
    BSTR _result = 0;
    HRESULT _hr = raw_LocalizeExpression(expressionString, decimalPointOption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IEngine::DelocalizeExpression ( _bstr_t localizedExpressionString, enum DecimalPointLocalizationOptions decimalPointOption ) {
    BSTR _result = 0;
    HRESULT _hr = raw_DelocalizeExpression(localizedExpressionString, decimalPointOption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IEngine::GetLocalizedDecimalPoint ( enum DecimalPointLocalizationOptions decimalPointOption ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetLocalizedDecimalPoint(decimalPointOption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long IEngine::DisplayMessageBox ( _bstr_t dlgTitle, _bstr_t messageText, enum MsgBoxTypes msgBoxType, long dlgOptions, long win32Flags ) {
    long _result = 0;
    HRESULT _hr = raw_DisplayMessageBox(dlgTitle, messageText, msgBoxType, dlgOptions, win32Flags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutMasterEngine ( IDispatch * MasterEngine ) {
    HRESULT _hr = put_MasterEngine(MasterEngine);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IEngine::PutRefMasterEngine ( IDispatch * MasterEngine ) {
    HRESULT _hr = putref_MasterEngine(MasterEngine);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IDispatchPtr IEngine::GetMasterEngine ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_MasterEngine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

HRESULT IEngine::GetToolMenuItemInfoEx ( long menuIndex, long itemIndex, BSTR * itemText, long * subMenuIndex, long * itemAttributes, long * uniqueItemID ) {
    HRESULT _hr = raw_GetToolMenuItemInfoEx(menuIndex, itemIndex, itemText, subMenuIndex, itemAttributes, uniqueItemID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::GetToolMenuItemInfoWithIDEx ( long uniqueItemID, BSTR * itemText, long * subMenuIndex, long * itemAttributes ) {
    HRESULT _hr = raw_GetToolMenuItemInfoWithIDEx(uniqueItemID, itemText, subMenuIndex, itemAttributes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::GetUseLocalizedDecimalPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseLocalizedDecimalPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUseLocalizedDecimalPoint ( VARIANT_BOOL enabled ) {
    HRESULT _hr = put_UseLocalizedDecimalPoint(enabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectFilePtr IEngine::NewPropertyObjectFile ( enum PropertyObjectFileTypes FileType ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = raw_NewPropertyObjectFile(FileType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

PropertyObjectFilePtr IEngine::GetGlobalsFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_GlobalsFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

UsersFilePtr IEngine::GetUsersFile ( ) {
    struct UsersFile * _result = 0;
    HRESULT _hr = get_UsersFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UsersFilePtr(_result, false);
}

PropertyObjectFilePtr IEngine::GetConfigFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_ConfigFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

StepTypePtr IEngine::NewStepType ( ) {
    struct StepType * _result = 0;
    HRESULT _hr = raw_NewStepType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepTypePtr(_result, false);
}

long IEngine::GetSmallImageList ( ) {
    long _result = 0;
    HRESULT _hr = get_SmallImageList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetLargeImageList ( ) {
    long _result = 0;
    HRESULT _hr = get_LargeImageList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::AddImage ( IPictureDisp * image, _bstr_t imageName ) {
    long _result = 0;
    HRESULT _hr = raw_AddImage(image, imageName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequenceFilePtr IEngine::GetSequenceFileEx ( _bstr_t SequenceFilePath, long getSeqFileFlags, enum TypeConflictHandlerTypes handlerType ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetSequenceFileEx(SequenceFilePath, getSeqFileFlags, handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

VARIANT_BOOL IEngine::ShouldAutoLaunchExternalReportViewer ( _bstr_t FilePath ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShouldAutoLaunchExternalReportViewer(FilePath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::CanCreateStep ( _bstr_t adapterKeyNameVal, _bstr_t stepTypeName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanCreateStep(adapterKeyNameVal, stepTypeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetDefaultAdapterIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_DefaultAdapterIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutDefaultAdapterIndex ( long index ) {
    HRESULT _hr = put_DefaultAdapterIndex(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::DisplayEditPathsInFilesDialog ( _bstr_t dlgTitle, long dlgOptions, const _variant_t & initialFile ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayEditPathsInFilesDialog(dlgTitle, dlgOptions, initialFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::DisplayRunTimeErrorDialogEx ( _bstr_t dlgTitle, struct SequenceContext * sequenceContextParam, long dlgOptions, VARIANT_BOOL * suspendExecution, VARIANT_BOOL * dontShowAgainForExecution, VARIANT_BOOL * dontShowAgainForBatch, enum RTEOptions * runTimeErrorAction ) {
    HRESULT _hr = raw_DisplayRunTimeErrorDialogEx(dlgTitle, sequenceContextParam, dlgOptions, suspendExecution, dontShowAgainForExecution, dontShowAgainForBatch, runTimeErrorAction);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayBrowseExprDialogEx ( _bstr_t dlgTitle, struct PropertyObject * objectToBrowse, _bstr_t expressionIn, long selectionStartIn, long selectionEndIn, _bstr_t initialVariableName, long dlgOptions, BSTR * expressionOut, long * selectionStartOut, long * selectionEndOut ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayBrowseExprDialogEx(dlgTitle, objectToBrowse, expressionIn, selectionStartIn, selectionEndIn, initialVariableName, dlgOptions, expressionOut, selectionStartOut, selectionEndOut, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::DisplayBrowsePropertyObjectDialog ( _bstr_t dlgTitle, struct PropertyObject * objectToBrowse, _bstr_t initialLocation, long dlgOptions ) {
    HRESULT _hr = raw_DisplayBrowsePropertyObjectDialog(dlgTitle, objectToBrowse, initialLocation, dlgOptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::SaveAllModifiedSeqFiles ( long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SaveAllModifiedSeqFiles(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ExecutionPtr IEngine::CallFrontEndCallbackEx ( _bstr_t sequenceNameParam, struct PropertyObject * argumentList, enum TypeConflictHandlerTypes handlerType, long reservedParam ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_CallFrontEndCallbackEx(sequenceNameParam, argumentList, handlerType, reservedParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

VARIANT_BOOL IEngine::DisplaySequenceFileCallbacksDialog ( _bstr_t dlgTitle, struct SequenceFile * sequenceFileParam, long dlgOptions, BSTR * sequenceToEdit, long * numCallbacksAdded, long * numCallbacksDeleted ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplaySequenceFileCallbacksDialog(dlgTitle, sequenceFileParam, dlgOptions, sequenceToEdit, numCallbacksAdded, numCallbacksDeleted, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetProductRegistrationInfo ( BSTR * userName, BSTR * companyName, BSTR * serialNumber ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetProductRegistrationInfo(userName, companyName, serialNumber, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::SetProductRegistrationInfo ( _bstr_t userName, _bstr_t companyName, _bstr_t serialNumber ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetProductRegistrationInfo(userName, companyName, serialNumber, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::ReleaseSequenceFileEx ( struct SequenceFile * sequenceFileToRelease, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ReleaseSequenceFileEx(sequenceFileToRelease, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

WorkspaceFilePtr IEngine::GetCurrentWorkspaceFile ( ) {
    struct WorkspaceFile * _result = 0;
    HRESULT _hr = get_CurrentWorkspaceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceFilePtr(_result, false);
}

void IEngine::PutCurrentWorkspaceFile ( struct WorkspaceFile * val ) {
    HRESULT _hr = put_CurrentWorkspaceFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IEngine::PutRefCurrentWorkspaceFile ( struct WorkspaceFile * val ) {
    HRESULT _hr = putref_CurrentWorkspaceFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IEngine::GetSecondsSinceStart ( ) {
    double _result = 0;
    HRESULT _hr = get_SecondsSinceStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::RegisterModalWindow ( struct SequenceContext * sequenceContextParam, long modalHWND, VARIANT_BOOL * shouldAbort ) {
    long _result = 0;
    HRESULT _hr = raw_RegisterModalWindow(sequenceContextParam, modalHWND, shouldAbort, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::UnregisterModalWindow ( long modalID ) {
    HRESULT _hr = raw_UnregisterModalWindow(modalID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayFileDialog ( _bstr_t dlgTitle, _bstr_t okButtonText, _bstr_t initialPath, SAFEARRAY * * selectedPaths, SAFEARRAY * * absolutePaths, long openFileDialogFlags, _bstr_t defaultExtension, long win32Flags, _bstr_t fileFilter, const _variant_t & currentFile, VARIANT * fileFilterIndex, VARIANT * dirHistoryList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayFileDialog(dlgTitle, okButtonText, initialPath, selectedPaths, absolutePaths, openFileDialogFlags, defaultExtension, win32Flags, fileFilter, currentFile, fileFilterIndex, dirHistoryList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::SerializeObjects ( SAFEARRAY * objects, long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_SerializeObjects(objects, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IEngine::UnserializeObjects ( _bstr_t stream, long reservedParam, enum TypeConflictHandlerTypes handlerType ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_UnserializeObjects(stream, reservedParam, handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetCheckOutFilesWhenEdited ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CheckOutFilesWhenEdited(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutCheckOutFilesWhenEdited ( VARIANT_BOOL checkOutFiles ) {
    HRESULT _hr = put_CheckOutFilesWhenEdited(checkOutFiles);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetCheckOutOnlySelectedFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CheckOutOnlySelectedFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutCheckOutOnlySelectedFiles ( VARIANT_BOOL onlySelectedFiles ) {
    HRESULT _hr = put_CheckOutOnlySelectedFiles(onlySelectedFiles);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IEngine::GetLastWorkspacePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LastWorkspacePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IEngine::PutLastWorkspacePath ( _bstr_t pathString ) {
    HRESULT _hr = put_LastWorkspacePath(pathString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetPromptWhenAddingFilesToSC ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PromptWhenAddingFilesToSC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutPromptWhenAddingFilesToSC ( VARIANT_BOOL promptAddFile ) {
    HRESULT _hr = put_PromptWhenAddingFilesToSC(promptAddFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetReloadDocsWhenOpeningWorkspace ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReloadDocsWhenOpeningWorkspace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutReloadDocsWhenOpeningWorkspace ( VARIANT_BOOL reloadDocs ) {
    HRESULT _hr = put_ReloadDocsWhenOpeningWorkspace(reloadDocs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetReloadWorkspaceAtStartup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReloadWorkspaceAtStartup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutReloadWorkspaceAtStartup ( VARIANT_BOOL reloadWorkspace ) {
    HRESULT _hr = put_ReloadWorkspaceAtStartup(reloadWorkspace);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetUseDialogForCheckOut ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseDialogForCheckOut(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUseDialogForCheckOut ( VARIANT_BOOL useDialog ) {
    HRESULT _hr = put_UseDialogForCheckOut(useDialog);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IEngine::DisplayWorkspaceBrowserDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    HRESULT _hr = raw_DisplayWorkspaceBrowserDialog(dlgTitle, dlgOptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IEngine::GetTypeUsageLocations ( _bstr_t typeNameParam ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetTypeUsageLocations(typeNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::ResetTypeInstances ( struct PropertyObject * typeParam, long resetTypeInstancesOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ResetTypeInstances(typeParam, resetTypeInstancesOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetShowHiddenProperties ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowHiddenProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutShowHiddenProperties ( VARIANT_BOOL show ) {
    HRESULT _hr = put_ShowHiddenProperties(show);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr IEngine::GetTypeDefinition ( _bstr_t typeNameParam ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetTypeDefinition(typeNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

SAFEARRAY * IEngine::GetTypeNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetTypeNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr IEngine::NewDataType ( enum PropertyValueTypes ValueType, VARIANT_BOOL asArray, _bstr_t typeNameParam, long options ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_NewDataType(ValueType, asArray, typeNameParam, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr IEngine::GetInsertStepMenuStructure ( struct PropertyObjectFile * SelectedFile, long hiddenFlags ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetInsertStepMenuStructure(SelectedFile, hiddenFlags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL IEngine::DisplayStepTypeMenuEditor ( _bstr_t dlgTitle, VARIANT_BOOL forSubsteps, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayStepTypeMenuEditor(dlgTitle, forSubsteps, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::LoadTypePaletteFiles ( ) {
    HRESULT _hr = raw_LoadTypePaletteFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::UnloadTypePaletteFiles ( ) {
    HRESULT _hr = raw_UnloadTypePaletteFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IEngine::GetTypePaletteFileList ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetTypePaletteFileList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::SetTypePaletteFileList ( SAFEARRAY * typePaletteFiles ) {
    HRESULT _hr = raw_SetTypePaletteFileList(typePaletteFiles);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IEngine::GetComputerName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ComputerName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IEngine::GetUniqueEngineId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UniqueEngineId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

PropertyObjectPtr IEngine::GetToolMenuStructure ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetToolMenuStructure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

SAFEARRAY * IEngine::GetResourceSymbols ( _bstr_t section ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetResourceSymbols(section, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::GetCVIAdapter_ExternalCVIPrj ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CVIAdapter_ExternalCVIPrj(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IEngine::PutCVIAdapter_ExternalCVIPrj ( _bstr_t val ) {
    HRESULT _hr = put_CVIAdapter_ExternalCVIPrj(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetCVIAdapter_ExecuteStepsInCVI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CVIAdapter_ExecuteStepsInCVI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutCVIAdapter_ExecuteStepsInCVI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CVIAdapter_ExecuteStepsInCVI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::CheckExpression ( struct PropertyObject * evaluationContext, _bstr_t expressionStr, long EvaluationOptions, BSTR * errorDescription, long * startErrPos, long * endErrPos ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CheckExpression(evaluationContext, expressionStr, EvaluationOptions, errorDescription, startErrPos, endErrPos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetRequireUserLogin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RequireUserLogin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutRequireUserLogin ( VARIANT_BOOL requireUser ) {
    HRESULT _hr = put_RequireUserLogin(requireUser);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IEngine::GetFileDialogDirHistoryList ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_FileDialogDirHistoryList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutFileDialogDirHistoryList ( SAFEARRAY * directories ) {
    HRESULT _hr = put_FileDialogDirHistoryList(directories);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IEngine::GetStationID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StationID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IEngine::PutStationID ( _bstr_t val ) {
    HRESULT _hr = put_StationID(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SequenceContextPtr IEngine::NewEditContext ( struct PropertyObject * obj, const _variant_t & editArgsParam, VARIANT * locationString ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = raw_NewEditContext(obj, editArgsParam, locationString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

_bstr_t IEngine::GetImageName ( long imageIndex ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetImageName(imageIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long IEngine::GetImageIndex ( _bstr_t imageName ) {
    long _result = 0;
    HRESULT _hr = raw_GetImageIndex(imageName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetNumImages ( ) {
    long _result = 0;
    HRESULT _hr = get_NumImages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum FileVersionAutoIncrement IEngine::GetSeqFileVersionAutoIncrementOpt ( ) {
    enum FileVersionAutoIncrement _result;
    HRESULT _hr = get_SeqFileVersionAutoIncrementOpt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutSeqFileVersionAutoIncrementOpt ( enum FileVersionAutoIncrement option ) {
    HRESULT _hr = put_SeqFileVersionAutoIncrementOpt(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr IEngine::CopyPropertyObject ( struct PropertyObject * srcObj ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_CopyPropertyObject(srcObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr IEngine::GetTemporaryGlobals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_TemporaryGlobals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

IUnknownPtr IEngine::GetSyncManager ( _bstr_t syncObjectName ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_GetSyncManager(syncObjectName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

enum RTEOptions IEngine::GetRTEOption ( ) {
    enum RTEOptions _result;
    HRESULT _hr = get_RTEOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutRTEOption ( enum RTEOptions option ) {
    HRESULT _hr = put_RTEOption(option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ExecutionPtr IEngine::NewHierarchicalExecution ( SAFEARRAY * sequenceCallSteps, long HierarchicalExecutionFlags, struct SequenceFile * sequenceFileParam, _bstr_t sequenceNameParam, struct SequenceFile * processModelParam, VARIANT_BOOL breakAtFirstStep, long executionTypeMaskParam, const _variant_t & sequenceArgsParam, const _variant_t & editArgsParam, const _variant_t & InteractiveArgsParam ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_NewHierarchicalExecution(sequenceCallSteps, HierarchicalExecutionFlags, sequenceFileParam, sequenceNameParam, processModelParam, breakAtFirstStep, executionTypeMaskParam, sequenceArgsParam, editArgsParam, InteractiveArgsParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

double IEngine::GetSecondsSince1970UniversalCoordinatedTime ( ) {
    double _result = 0;
    HRESULT _hr = get_SecondsSince1970UniversalCoordinatedTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayEditNumericFormatDialog ( _bstr_t dlgTitle, BSTR * NumericFormat, long dlgOptions, double sampleNumber ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayEditNumericFormatDialog(dlgTitle, NumericFormat, dlgOptions, sampleNumber, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr IEngine::GetInsertVariableMenuStructure ( struct PropertyObjectFile * SelectedFile, long hiddenFlags ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetInsertVariableMenuStructure(SelectedFile, hiddenFlags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long IEngine::IsCurrentSequenceFileVersion ( _bstr_t FilePath ) {
    long _result = 0;
    HRESULT _hr = raw_IsCurrentSequenceFileVersion(FilePath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IEngine::GetStationModelSequenceFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StationModelSequenceFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IEngine::PutStationModelSequenceFilePath ( _bstr_t ModelPath ) {
    HRESULT _hr = put_StationModelSequenceFilePath(ModelPath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IEngine::NotifyStartOfModalDialogEx ( struct SequenceContext * sequenceContextParam, VARIANT_BOOL * shouldAbort ) {
    long _result = 0;
    HRESULT _hr = raw_NotifyStartOfModalDialogEx(sequenceContextParam, shouldAbort, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IEngine::GetInternalOption ( enum InternalOptions option ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetInternalOption(option, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT IEngine::SetInternalOption ( enum InternalOptions option, const _variant_t & newValue ) {
    HRESULT _hr = raw_SetInternalOption(option, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IEngine::DisplayHelpTopic ( long tagID, _bstr_t helpFile, _bstr_t tableOfContentsFile, _bstr_t indexFile, _bstr_t homeFile, _bstr_t windowCaption ) {
    long _result = 0;
    HRESULT _hr = raw_DisplayHelpTopic(tagID, helpFile, tableOfContentsFile, indexFile, homeFile, windowCaption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayBreakpointDialog ( _bstr_t dlgTitle, struct SequenceContext * sequenceContextParam, struct Execution * executionParam, struct Step * selectedStep, enum StepGroups stepGroupParam, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayBreakpointDialog(dlgTitle, sequenceContextParam, executionParam, selectedStep, stepGroupParam, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SearchResultsPtr IEngine::SearchFiles ( _bstr_t searchString, long SearchOptions, long filterOptions, long elementsToSearch, SAFEARRAY * limitToAdapters, SAFEARRAY * limitToNamedProps, SAFEARRAY * limitToPropsOfNamedTypes, SAFEARRAY * openFilesToSearch, SAFEARRAY * directoriesAndFilePaths ) {
    struct SearchResults * _result = 0;
    HRESULT _hr = raw_SearchFiles(searchString, SearchOptions, filterOptions, elementsToSearch, limitToAdapters, limitToNamedProps, limitToPropsOfNamedTypes, openFilesToSearch, directoriesAndFilePaths, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SearchResultsPtr(_result, false);
}

long IEngine::GetWatchExpressionsChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetWatchExpressionsChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

WatchExpressionsPtr IEngine::GetWatchExpressions ( struct SequenceFile * clientSequenceFileParam, struct SequenceContext * scopingSeqContext, long filterOptions ) {
    struct WatchExpressions * _result = 0;
    HRESULT _hr = raw_GetWatchExpressions(clientSequenceFileParam, scopingSeqContext, filterOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WatchExpressionsPtr(_result, false);
}

HRESULT IEngine::SetLocationForNextDialog ( _bstr_t locationLookupString, long elementAtLocation, long selectionStart, long selectionLength ) {
    HRESULT _hr = raw_SetLocationForNextDialog(locationLookupString, elementAtLocation, selectionStart, selectionLength);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IEngine::DisplayHelpFile ( _bstr_t htmlFile, _bstr_t helpFile, _bstr_t tableOfContentsFile, _bstr_t indexFile, _bstr_t homeFile, _bstr_t windowCaption ) {
    long _result = 0;
    HRESULT _hr = raw_DisplayHelpFile(htmlFile, helpFile, tableOfContentsFile, indexFile, homeFile, windowCaption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::DisplayEditBreakAndWatchDialog ( _bstr_t dlgTitle, long dlgOptions, VARIANT * selectedItemParam ) {
    HRESULT _hr = raw_DisplayEditBreakAndWatchDialog(dlgTitle, dlgOptions, selectedItemParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayExpressionEditOptionsDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayExpressionEditOptionsDialog(dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SearchDirectoriesPtr IEngine::GetSearchDirectories ( ) {
    struct SearchDirectories * _result = 0;
    HRESULT _hr = get_SearchDirectories(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SearchDirectoriesPtr(_result, false);
}

HRESULT IEngine::LoadTypePaletteFilesEx ( enum TypeConflictHandlerTypes handlerType, long options ) {
    HRESULT _hr = raw_LoadTypePaletteFilesEx(handlerType, options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IEngine::RegisterUIMessage ( _bstr_t messageName ) {
    long _result = 0;
    HRESULT _hr = raw_RegisterUIMessage(messageName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ExternalReportViewersPtr IEngine::GetExternalReportViewers ( ) {
    struct ExternalReportViewers * _result = 0;
    HRESULT _hr = get_ExternalReportViewers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExternalReportViewersPtr(_result, false);
}

WorkspaceFilePtr IEngine::NewWorkspaceFile ( ) {
    struct WorkspaceFile * _result = 0;
    HRESULT _hr = raw_NewWorkspaceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceFilePtr(_result, false);
}

WorkspaceFilePtr IEngine::OpenWorkspaceFile ( _bstr_t workspaceFilePath, long options, enum TypeConflictHandlerTypes handlerType ) {
    struct WorkspaceFile * _result = 0;
    HRESULT _hr = raw_OpenWorkspaceFile(workspaceFilePath, options, handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspaceFilePtr(_result, false);
}

HRESULT IEngine::ReloadStringResourceFiles ( ) {
    HRESULT _hr = raw_ReloadStringResourceFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

AdapterPtr IEngine::GetAdapterByKeyName ( _bstr_t AdapterKeyName ) {
    struct Adapter * _result = 0;
    HRESULT _hr = raw_GetAdapterByKeyName(AdapterKeyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdapterPtr(_result, false);
}

HRESULT IEngine::PostUIMessage ( struct Execution * executionParam, struct Thread * threadParam, enum UIMessageCodes eventCode, double numericDataParam, _bstr_t stringDataParam, IUnknown * activeXDataParam, VARIANT_BOOL synchronous ) {
    HRESULT _hr = raw_PostUIMessage(executionParam, threadParam, eventCode, numericDataParam, stringDataParam, activeXDataParam, synchronous);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayBrowseExprDialogFromControl ( IUnknown * expressionEdit, _bstr_t dlgTitle, long selectionStart, long selectionEnd, _bstr_t initVarName, long dlgOptions, VARIANT_BOOL * contextChanged ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayBrowseExprDialogFromControl(expressionEdit, dlgTitle, selectionStart, selectionEnd, initVarName, dlgOptions, contextChanged, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ExpressionPtr IEngine::NewExpression ( ) {
    struct Expression * _result = 0;
    HRESULT _hr = raw_NewExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionPtr(_result, false);
}

StationOptionsPtr IEngine::GetStationOptions ( ) {
    struct StationOptions * _result = 0;
    HRESULT _hr = get_StationOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StationOptionsPtr(_result, false);
}

VARIANT_BOOL IEngine::DisplayStepTypeMenuEditorEx ( _bstr_t dlgTitle, struct PropertyObjectFile * SelectedFile, VARIANT_BOOL forSubsteps, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayStepTypeMenuEditorEx(dlgTitle, SelectedFile, forSubsteps, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TypeUsageListPtr IEngine::NewTypeUsageList ( long reservedParam ) {
    struct TypeUsageList * _result = 0;
    HRESULT _hr = raw_NewTypeUsageList(reservedParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TypeUsageListPtr(_result, false);
}

SAFEARRAY * IEngine::UnserializeObjectsAndTypes ( _bstr_t stream, struct TypeUsageList * * typesUsed, long reservedParam, enum TypeConflictHandlerTypes handlerType ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_UnserializeObjectsAndTypes(stream, typesUsed, reservedParam, handlerType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ImagesPtr IEngine::GetImages ( ) {
    struct Images * _result = 0;
    HRESULT _hr = get_Images(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ImagesPtr(_result, false);
}

EditTimeMenuItemsPtr IEngine::GetEditTimeToolMenuItems ( long reserved ) {
    struct EditTimeMenuItems * _result = 0;
    HRESULT _hr = raw_GetEditTimeToolMenuItems(reserved, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EditTimeMenuItemsPtr(_result, false);
}

RunTimeMenuItemsPtr IEngine::GetRunTimeToolMenuItems ( const _variant_t & editArgsParam, long reserved ) {
    struct RunTimeMenuItems * _result = 0;
    HRESULT _hr = raw_GetRunTimeToolMenuItems(editArgsParam, reserved, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RunTimeMenuItemsPtr(_result, false);
}

VARIANT_BOOL IEngine::GetWatchExpressionsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WatchExpressionsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutWatchExpressionsEnabled ( VARIANT_BOOL enable ) {
    HRESULT _hr = put_WatchExpressionsEnabled(enable);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IEngine::WriteToolMenuToDisk ( long reserved ) {
    HRESULT _hr = raw_WriteToolMenuToDisk(reserved);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::CreateNewUniqueStepIds ( SAFEARRAY * steps ) {
    HRESULT _hr = raw_CreateNewUniqueStepIds(steps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum LicenseTypes IEngine::GetLicenseType ( ) {
    enum LicenseTypes _result;
    HRESULT _hr = get_LicenseType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::GetPersistBreakpoints ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PersistBreakpoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutPersistBreakpoints ( VARIANT_BOOL returnVal ) {
    HRESULT _hr = put_PersistBreakpoints(returnVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IEngine::GetPersistWatchExpressions ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PersistWatchExpressions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutPersistWatchExpressions ( VARIANT_BOOL returnVal ) {
    HRESULT _hr = put_PersistWatchExpressions(returnVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IEngine::GetLicenseDescription ( long reserved ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetLicenseDescription(reserved, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IEngine::GetLocationForNextDialog ( BSTR * locationLookupString, long * elementAtLocation, long * selectionStart, long * selectionLength, VARIANT_BOOL clearLoc ) {
    HRESULT _hr = raw_GetLocationForNextDialog(locationLookupString, elementAtLocation, selectionStart, selectionLength, clearLoc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IEngine::SetConfigDirectory ( _bstr_t Path, VARIANT_BOOL CopyFilesOnEngineShutdown ) {
    HRESULT _hr = raw_SetConfigDirectory(Path, CopyFilesOnEngineShutdown);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IEngine::DisplayLockUnlockDialog ( _bstr_t dlgTitle, _bstr_t dlgMsg, struct PropertyObject * propObject, long options, VARIANT * passwordString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayLockUnlockDialog(dlgTitle, dlgMsg, propObject, options, passwordString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

UserPtr IEngine::GetUserGroup ( _bstr_t userGroupName ) {
    struct User * _result = 0;
    HRESULT _hr = raw_GetUserGroup(userGroupName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UserPtr(_result, false);
}

VARIANT_BOOL IEngine::GetPersistConfigFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PersistConfigFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutPersistConfigFile ( VARIANT_BOOL returnVal ) {
    HRESULT _hr = put_PersistConfigFile(returnVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SequenceFileDifferPtr IEngine::DiffSequenceFiles ( struct SequenceFile * sequenceFile1Param, struct SequenceFile * sequenceFile2Param, long options ) {
    struct SequenceFileDiffer * _result = 0;
    HRESULT _hr = raw_DiffSequenceFiles(sequenceFile1Param, sequenceFile2Param, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileDifferPtr(_result, false);
}

LocationsPtr IEngine::NewLocations ( ) {
    struct Locations * _result = 0;
    HRESULT _hr = raw_NewLocations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationsPtr(_result, false);
}

UndoItemCreatorPtr IEngine::NewUndoItemCreator ( enum EditKinds kindParam, struct PropertyObjectFile * editedFileParam, _bstr_t editDescription ) {
    struct UndoItemCreator * _result = 0;
    HRESULT _hr = raw_NewUndoItemCreator(kindParam, editedFileParam, editDescription, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UndoItemCreatorPtr(_result, false);
}

OutputMessagesPtr IEngine::GetOutputMessages ( ) {
    struct OutputMessages * _result = 0;
    HRESULT _hr = raw_GetOutputMessages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return OutputMessagesPtr(_result, false);
}

OutputMessagePtr IEngine::NewOutputMessage ( _bstr_t messageText, _bstr_t categoryText, enum OutputMessageSeverityTypes Severity, struct SequenceContext * SequenceContext ) {
    struct OutputMessage * _result = 0;
    HRESULT _hr = raw_NewOutputMessage(messageText, categoryText, Severity, SequenceContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return OutputMessagePtr(_result, false);
}

VARIANT_BOOL IEngine::GetOutputMessagesEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OutputMessagesEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutOutputMessagesEnabled ( VARIANT_BOOL enable ) {
    HRESULT _hr = put_OutputMessagesEnabled(enable);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OutputMessagesPtr IEngine::NewOutputMessages ( ) {
    struct OutputMessages * _result = 0;
    HRESULT _hr = raw_NewOutputMessages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return OutputMessagesPtr(_result, false);
}

UndoStackPtr IEngine::NewUndoStack ( ) {
    struct UndoStack * _result = 0;
    HRESULT _hr = raw_NewUndoStack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UndoStackPtr(_result, false);
}

SAFEARRAY * IEngine::ParseLookupString ( _bstr_t lookupString, long options ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ParseLookupString(lookupString, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum PromptResults IEngine::DisplaySaveOverOldFormatDialog ( _bstr_t Path, enum PerformActionOptions * promptForOverwriteOption, _bstr_t dlgTitle, long dlgOptions ) {
    enum PromptResults _result;
    HRESULT _hr = raw_DisplaySaveOverOldFormatDialog(Path, promptForOverwriteOption, dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayPreconditionBuilderDialog ( _bstr_t dlgTitle, BSTR * preconditionExpr, struct Sequence * Sequence, long dlgOptions, struct SequenceContext * SequenceContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayPreconditionBuilderDialog(dlgTitle, preconditionExpr, Sequence, dlgOptions, SequenceContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IEngine::DisplayConfigureTypePalettesDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayConfigureTypePalettesDialog(dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

EvaluationTypesPtr IEngine::NewEvaluationTypes ( long initialPropertyValueTypes ) {
    struct EvaluationTypes * _result = 0;
    HRESULT _hr = raw_NewEvaluationTypes(initialPropertyValueTypes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EvaluationTypesPtr(_result, false);
}

VARIANT_BOOL IEngine::DisplayEditNumericFormatDialogEx ( _bstr_t dlgTitle, BSTR * NumericFormat, VARIANT_BOOL * validFormat, long dlgOptions, double sampleNumber ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayEditNumericFormatDialogEx(dlgTitle, NumericFormat, validFormat, dlgOptions, sampleNumber, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

FileInformationPtr IEngine::GetFileInformation ( _bstr_t Path ) {
    struct FileInformation * _result = 0;
    HRESULT _hr = raw_GetFileInformation(Path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FileInformationPtr(_result, false);
}

enum PromptResults IEngine::DisplaySaveAsPreviousOverExistingFileDialog ( _bstr_t Path, _bstr_t dlgTitle ) {
    enum PromptResults _result;
    HRESULT _hr = raw_DisplaySaveAsPreviousOverExistingFileDialog(Path, dlgTitle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectFilePtr IEngine::GetTemplatesFile ( long options ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = raw_GetTemplatesFile(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

long IEngine::AcquireLicense ( enum ApplicationLicenses license, long options ) {
    long _result = 0;
    HRESULT _hr = raw_AcquireLicense(license, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IEngine::ReleaseLicense ( long licenseHandle, long reserved ) {
    HRESULT _hr = raw_ReleaseLicense(licenseHandle, reserved);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum ApplicationLicenses IEngine::GetApplicationLicense ( ) {
    enum ApplicationLicenses _result;
    HRESULT _hr = get_ApplicationLicense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IEngine::GetUndoLimit ( ) {
    long _result = 0;
    HRESULT _hr = get_UndoLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IEngine::PutUndoLimit ( long val ) {
    HRESULT _hr = put_UndoLimit(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IEngine::GetTestStandPath ( enum TestStandPaths testStandPath ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTestStandPath(testStandPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

UtilityPtr IEngine::GetUtility ( ) {
    struct Utility * _result = 0;
    HRESULT _hr = get_Utility(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UtilityPtr(_result, false);
}

//
// interface SequenceFile wrapper method implementations
//

SequencePtr SequenceFile::GetSequence ( long index ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_GetSequence(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

SequencePtr SequenceFile::GetSequenceByName ( _bstr_t sequenceNameParam ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_GetSequenceByName(sequenceNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

VARIANT_BOOL SequenceFile::SequenceNameExists ( _bstr_t sequenceNameParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SequenceNameExists(sequenceNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceFile::InsertSequence ( struct Sequence * sequenceToInsert ) {
    HRESULT _hr = raw_InsertSequence(sequenceToInsert);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequencePtr SequenceFile::RemoveSequence ( long index ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_RemoveSequence(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

HRESULT SequenceFile::DeleteSequence ( long index ) {
    HRESULT _hr = raw_DeleteSequence(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SequenceFile::Save ( _bstr_t pathString ) {
    HRESULT _hr = raw_Save(pathString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequenceFilePtr SequenceFile::GetModelSequenceFile ( BSTR * modelDescriptionString ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetModelSequenceFile(modelDescriptionString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

SequencePtr SequenceFile::CreateCallbackOverrideSequence ( _bstr_t callbackName, VARIANT_BOOL allowCopyDefaultSteps ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_CreateCallbackOverrideSequence(callbackName, allowCopyDefaultSteps, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

SequenceContextPtr SequenceFile::NewEditContext ( ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = raw_NewEditContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

HRESULT SequenceFile::IncChangeCount ( ) {
    HRESULT _hr = raw_IncChangeCount();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long SequenceFile::GetSequenceIndex ( _bstr_t sequenceNameParam ) {
    long _result = 0;
    HRESULT _hr = raw_GetSequenceIndex(sequenceNameParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr SequenceFile::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long SequenceFile::GetNumSequences ( ) {
    long _result = 0;
    HRESULT _hr = get_NumSequences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr SequenceFile::GetFileGlobalsDefaultValues ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_FileGlobalsDefaultValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t SequenceFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SequenceFile::PutPath ( _bstr_t val ) {
    HRESULT _hr = put_Path(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleLoadOptions SequenceFile::GetModuleLoadOption ( ) {
    enum ModuleLoadOptions _result;
    HRESULT _hr = get_ModuleLoadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutModuleLoadOption ( enum ModuleLoadOptions val ) {
    HRESULT _hr = put_ModuleLoadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleUnloadOptions SequenceFile::GetModuleUnloadOption ( ) {
    enum ModuleUnloadOptions _result;
    HRESULT _hr = get_ModuleUnloadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutModuleUnloadOption ( enum ModuleUnloadOptions val ) {
    HRESULT _hr = put_ModuleUnloadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceFile::GetHasModel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceFile::GetUnloadCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UnloadCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutUnloadCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UnloadCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceFile::GetIsExecuting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExecuting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceFile::GetChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceFile::LoadModules ( long loadOptions, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadModules(loadOptions, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectFilePtr SequenceFile::AsPropertyObjectFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = raw_AsPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

_bstr_t SequenceFile::GetModelAbsolutePath ( VARIANT_BOOL * modelExists ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetModelAbsolutePath(modelExists, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT SequenceFile::InsertSequenceEx ( long index, struct Sequence * sequenceToInsert ) {
    HRESULT _hr = raw_InsertSequenceEx(index, sequenceToInsert);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum SequenceFileTypes SequenceFile::GetSequenceFileType ( ) {
    enum SequenceFileTypes _result;
    HRESULT _hr = get_SequenceFileType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutSequenceFileType ( enum SequenceFileTypes val ) {
    HRESULT _hr = put_SequenceFileType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceFile::GetCanUnload ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUnload(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceFile::UnloadModules ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnloadModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceFile::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum ModelOptions SequenceFile::GetModelOption ( ) {
    enum ModelOptions _result;
    HRESULT _hr = get_ModelOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutModelOption ( enum ModelOptions val ) {
    HRESULT _hr = put_ModelOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SequenceFile::GetModelPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ModelPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SequenceFile::PutModelPath ( _bstr_t val ) {
    HRESULT _hr = put_ModelPath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * SequenceFile::GetReservedCallbackNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetReservedCallbackNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * SequenceFile::GetModelCallbackNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetModelCallbackNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum SeqFileBatchSynchronizationOptions SequenceFile::GetBatchSyncOption ( ) {
    enum SeqFileBatchSynchronizationOptions _result;
    HRESULT _hr = get_BatchSyncOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceFile::PutBatchSyncOption ( enum SeqFileBatchSynchronizationOptions val ) {
    HRESULT _hr = put_BatchSyncOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT SequenceFile::AddLoadReference ( ) {
    HRESULT _hr = raw_AddLoadReference();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface SelectedBreakpointItem wrapper method implementations
//

SequenceFilePtr SelectedBreakpointItem::GetSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_SequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

_bstr_t SelectedBreakpointItem::GetSequenceName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum StepGroups SelectedBreakpointItem::GetStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t SelectedBreakpointItem::GetStepId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StepId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL SelectedBreakpointItem::IsEndSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsEndSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Sequence wrapper method implementations
//

long Sequence::GetNumSteps ( enum StepGroups stepGroupParam ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumSteps(stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

StepPtr Sequence::GetStep ( long index, enum StepGroups stepGroupParam ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_GetStep(index, stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

StepPtr Sequence::GetStepByName ( _bstr_t nameOfStep, enum StepGroups stepGroupParam ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_GetStepByName(nameOfStep, stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

HRESULT Sequence::InsertStep ( struct Step * stepToInsert, long index, enum StepGroups stepGroupParam ) {
    HRESULT _hr = raw_InsertStep(stepToInsert, index, stepGroupParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

StepPtr Sequence::RemoveStep ( long index, enum StepGroups stepGroupParam ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_RemoveStep(index, stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

HRESULT Sequence::DeleteStep ( long index, enum StepGroups stepGroupParam ) {
    HRESULT _hr = raw_DeleteStep(index, stepGroupParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Sequence::StepNameExists ( _bstr_t nameOfStep, enum StepGroups stepGroupParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StepNameExists(nameOfStep, stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Sequence::EvalEntryPointNameExpression ( struct SequenceFile * sequenceFileParam ) {
    BSTR _result = 0;
    HRESULT _hr = raw_EvalEntryPointNameExpression(sequenceFileParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Sequence::EvalEntryPointEnabledExpression ( struct SequenceFile * sequenceFileParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EvalEntryPointEnabledExpression(sequenceFileParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Sequence::GetEntryPointMenuFromHint ( _bstr_t menuNameList ) {
    long _result = 0;
    HRESULT _hr = raw_GetEntryPointMenuFromHint(menuNameList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Sequence::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long Sequence::GetStepIndex ( _bstr_t nameOfStep, enum StepGroups stepGroupParam ) {
    long _result = 0;
    HRESULT _hr = raw_GetStepIndex(nameOfStep, stepGroupParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Sequence::GetParameters ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Parameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr Sequence::GetLocals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Locals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL Sequence::GetShowEntryPointForFileWindow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowEntryPointForFileWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutShowEntryPointForFileWindow ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowEntryPointForFileWindow(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetShowEntryPointForExeWindow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowEntryPointForExeWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutShowEntryPointForExeWindow ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowEntryPointForExeWindow(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetEntryPointInitiallyHidden ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EntryPointInitiallyHidden(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutEntryPointInitiallyHidden ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EntryPointInitiallyHidden(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SequenceTypes Sequence::GetType ( ) {
    enum SequenceTypes _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutType ( enum SequenceTypes val ) {
    HRESULT _hr = put_Type(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Sequence::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Sequence::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetGotoCleanupOnFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GotoCleanupOnFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutGotoCleanupOnFailure ( VARIANT_BOOL val ) {
    HRESULT _hr = put_GotoCleanupOnFailure(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetDisableResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DisableResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutDisableResults ( VARIANT_BOOL val ) {
    HRESULT _hr = put_DisableResults(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetShowEntryPointForEditorOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowEntryPointForEditorOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutShowEntryPointForEditorOnly ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowEntryPointForEditorOnly(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetShowEntryPointForAllWindows ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowEntryPointForAllWindows(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutShowEntryPointForAllWindows ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowEntryPointForAllWindows(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetBreakOnEnd ( enum StepGroups stepGroupParam, const _variant_t & executionParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBreakOnEnd(stepGroupParam, executionParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Sequence::SetBreakOnEnd ( enum StepGroups stepGroupParam, VARIANT_BOOL breakOnEnd, const _variant_t & executionParam ) {
    HRESULT _hr = raw_SetBreakOnEnd(stepGroupParam, breakOnEnd, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Sequence::LoadModules ( long loadOptions, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadModules(loadOptions, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum SequenceTypes Sequence::GetEffectiveType ( ) {
    enum SequenceTypes _result;
    HRESULT _hr = raw_GetEffectiveType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Sequence::EvalEntryPointNameExpressionEx ( struct EditArgs * EditArgs ) {
    BSTR _result = 0;
    HRESULT _hr = raw_EvalEntryPointNameExpressionEx(EditArgs, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Sequence::EvalEntryPointEnabledExpressionEx ( struct EditArgs * EditArgs ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EvalEntryPointEnabledExpressionEx(EditArgs, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Sequence::GetEntryPointIgnoreClient ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EntryPointIgnoreClient(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutEntryPointIgnoreClient ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EntryPointIgnoreClient(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetEntryPointCheckToSaveTitledSeqFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EntryPointCheckToSaveTitledSeqFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutEntryPointCheckToSaveTitledSeqFiles ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EntryPointCheckToSaveTitledSeqFiles(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::UnloadModules ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnloadModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequenceFilePtr Sequence::GetSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_SequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

VARIANT_BOOL Sequence::GetAllowInteractiveExecutionOfEntryPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowInteractiveExecutionOfEntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutAllowInteractiveExecutionOfEntryPoint ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AllowInteractiveExecutionOfEntryPoint(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetOptimizeNonReentrantCalls ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OptimizeNonReentrantCalls(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutOptimizeNonReentrantCalls ( VARIANT_BOOL val ) {
    HRESULT _hr = put_OptimizeNonReentrantCalls(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Sequence::GetCopyStepsOnOverride ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CopyStepsOnOverride(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Sequence::PutCopyStepsOnOverride ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CopyStepsOnOverride(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Sequence::SetBreakOnEndSettings ( enum StepGroups stepGroupParam, VARIANT_BOOL isSet, VARIANT_BOOL enabled, long passCount, _bstr_t Condition, const _variant_t & executionParam ) {
    HRESULT _hr = raw_SetBreakOnEndSettings(stepGroupParam, isSet, enabled, passCount, Condition, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Sequence::GetBreakOnEndSettings ( enum StepGroups stepGroupParam, VARIANT_BOOL * isSet, VARIANT_BOOL * enabled, long * passCount, BSTR * Condition, const _variant_t & executionParam ) {
    HRESULT _hr = raw_GetBreakOnEndSettings(stepGroupParam, isSet, enabled, passCount, Condition, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Sequence::GetEntryPointNameExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EntryPointNameExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Sequence::PutEntryPointNameExpression ( _bstr_t val ) {
    HRESULT _hr = put_EntryPointNameExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Sequence::GetEntryPointEnabledExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EntryPointEnabledExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Sequence::PutEntryPointEnabledExpression ( _bstr_t val ) {
    HRESULT _hr = put_EntryPointEnabledExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Sequence::GetEntryPointMenuHint ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EntryPointMenuHint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Sequence::PutEntryPointMenuHint ( _bstr_t val ) {
    HRESULT _hr = put_EntryPointMenuHint(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Sequence::CreateNewUniqueStepIds ( ) {
    HRESULT _hr = raw_CreateNewUniqueStepIds();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

StepPtr Sequence::GetStepByUniqueId ( _bstr_t UniqueStepId ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_GetStepByUniqueId(UniqueStepId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

VARIANT_BOOL Sequence::GetHasMismatchedBlocks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMismatchedBlocks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Sequence::GetRequirements ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Requirements(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long Sequence::GetSequenceIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SequenceIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Sequence::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface InteractiveArgs wrapper method implementations
//

long InteractiveArgs::GetStepIndex ( long arrayIndexParam ) {
    long _result = 0;
    HRESULT _hr = raw_GetStepIndex(arrayIndexParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT InteractiveArgs::AddStepIndex ( long stepIndexParam ) {
    HRESULT _hr = raw_AddStepIndex(stepIndexParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL InteractiveArgs::ContainsStep ( long stepIndexParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ContainsStep(stepIndexParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT InteractiveArgs::ClearStepList ( ) {
    HRESULT _hr = raw_ClearStepList();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr InteractiveArgs::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

enum StepGroups InteractiveArgs::GetStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InteractiveArgs::PutStepGroup ( enum StepGroups val ) {
    HRESULT _hr = put_StepGroup(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long InteractiveArgs::GetNumSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_NumSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InteractiveArgs::GetLoopCount ( ) {
    long _result = 0;
    HRESULT _hr = get_LoopCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InteractiveArgs::PutLoopCount ( long val ) {
    HRESULT _hr = put_LoopCount(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t InteractiveArgs::GetStopExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StopExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void InteractiveArgs::PutStopExpression ( _bstr_t val ) {
    HRESULT _hr = put_StopExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SequencePtr InteractiveArgs::GetSequence ( ) {
    struct Sequence * _result = 0;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

void InteractiveArgs::PutSequence ( struct Sequence * val ) {
    HRESULT _hr = put_Sequence(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void InteractiveArgs::PutRefSequence ( struct Sequence * val ) {
    HRESULT _hr = putref_Sequence(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface InteractiveContext wrapper method implementations
//

PropertyObjectPtr InteractiveContext::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL InteractiveContext::GetIsRootExecution ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRootExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InteractiveContext::GetSavedPreviousStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SavedPreviousStepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InteractiveContext::GetSavedNextStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SavedNextStepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long InteractiveContext::GetSavedStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SavedStepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

InteractiveArgsPtr InteractiveContext::GetInteractiveArgs ( ) {
    struct InteractiveArgs * _result = 0;
    HRESULT _hr = get_InteractiveArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InteractiveArgsPtr(_result, false);
}

//
// interface Step wrapper method implementations
//

PropertyObjectPtr Step::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL Step::ExecuteEditSubstep ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExecuteEditSubstep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::SpecifyModule ( long specModOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SpecifyModule(specModOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::GetIsSequenceCall ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSequenceCall(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Step::GetAdapterKeyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_AdapterKeyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Step::GetBreakOnStep ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutBreakOnStep ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BreakOnStep(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetRunMode ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RunMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutRunMode ( _bstr_t val ) {
    HRESULT _hr = put_RunMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetRunTimeRunMode ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RunTimeRunMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutRunTimeRunMode ( _bstr_t val ) {
    HRESULT _hr = put_RunTimeRunMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetStepFailCausesSequenceFail ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StepFailCausesSequenceFail(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutStepFailCausesSequenceFail ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StepFailCausesSequenceFail(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetPrecondition ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Precondition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPrecondition ( _bstr_t val ) {
    HRESULT _hr = put_Precondition(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Step::GetCanSpecifyModule ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanSpecifyModule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::GetCanExecuteEditSubstep ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanExecuteEditSubstep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Step::GetPassAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PassAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPassAction ( _bstr_t val ) {
    HRESULT _hr = put_PassAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetPassActionTarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PassActionTarget(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPassActionTarget ( _bstr_t val ) {
    HRESULT _hr = put_PassActionTarget(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetFailAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FailAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutFailAction ( _bstr_t val ) {
    HRESULT _hr = put_FailAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetFailActionTarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FailActionTarget(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutFailActionTarget ( _bstr_t val ) {
    HRESULT _hr = put_FailActionTarget(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomTrueAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomTrueAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomTrueAction ( _bstr_t val ) {
    HRESULT _hr = put_CustomTrueAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomTrueActionTarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomTrueActionTarget(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomTrueActionTarget ( _bstr_t val ) {
    HRESULT _hr = put_CustomTrueActionTarget(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomFalseAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomFalseAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomFalseAction ( _bstr_t val ) {
    HRESULT _hr = put_CustomFalseAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomFalseActionTarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomFalseActionTarget(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomFalseActionTarget ( _bstr_t val ) {
    HRESULT _hr = put_CustomFalseActionTarget(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomActionExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomActionExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomActionExpression ( _bstr_t val ) {
    HRESULT _hr = put_CustomActionExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetPassActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PassActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPassActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_PassActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetFailActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FailActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutFailActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_FailActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomTrueActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomTrueActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomTrueActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_CustomTrueActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetCustomFalseActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomFalseActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutCustomFalseActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_CustomFalseActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetLoopType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutLoopType ( _bstr_t val ) {
    HRESULT _hr = put_LoopType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetLoopWhileExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopWhileExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutLoopWhileExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopWhileExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetLoopStatusExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopStatusExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutLoopStatusExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopStatusExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetLoopInitExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopInitExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutLoopInitExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopInitExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetLoopIncExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopIncExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutLoopIncExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopIncExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetStatusExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StatusExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutStatusExpression ( _bstr_t val ) {
    HRESULT _hr = put_StatusExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetResultStatus ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ResultStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t Step::GetPreExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PreExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPreExpression ( _bstr_t val ) {
    HRESULT _hr = put_PreExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetPostExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PostExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutPostExpression ( _bstr_t val ) {
    HRESULT _hr = put_PostExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetRecordResult ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RecordResult(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutRecordResult ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RecordResult(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleLoadOptions Step::GetModuleLoadOption ( ) {
    enum ModuleLoadOptions _result;
    HRESULT _hr = get_ModuleLoadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutModuleLoadOption ( enum ModuleLoadOptions val ) {
    HRESULT _hr = put_ModuleLoadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleUnloadOptions Step::GetModuleUnloadOption ( ) {
    enum ModuleUnloadOptions _result;
    HRESULT _hr = get_ModuleUnloadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutModuleUnloadOption ( enum ModuleUnloadOptions val ) {
    HRESULT _hr = put_ModuleUnloadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * Step::GetSmallIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_SmallIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPictureDisp * Step::GetLargeIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_LargeIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetSmallIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SmallIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetLargeIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_LargeIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Step::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutResultStatus ( _bstr_t val ) {
    HRESULT _hr = put_ResultStatus(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetCancelCurrentExecution ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CancelCurrentExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutCancelCurrentExecution ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CancelCurrentExecution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetCausedSequenceFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CausedSequenceFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutCausedSequenceFailure ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CausedSequenceFailure(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum StepGroups Step::GetStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_StepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequencePtr Step::GetSequence ( ) {
    struct Sequence * _result = 0;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

HRESULT Step::SetRunModeEx ( _bstr_t newRunMode, const _variant_t & executionParam ) {
    HRESULT _hr = raw_SetRunModeEx(newRunMode, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Step::GetRunModeEx ( const _variant_t & executionParam ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetRunModeEx(executionParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT Step::SetBreakOnStepEx ( VARIANT_BOOL newBreakSetting, const _variant_t & executionParam ) {
    HRESULT _hr = raw_SetBreakOnStepEx(newBreakSetting, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Step::GetBreakOnStepEx ( const _variant_t & executionParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBreakOnStepEx(executionParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::LoadModule ( long loadOptions, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadModule(loadOptions, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Step::GetResultStatusDisplayString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetResultStatusDisplayString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t Step::GetExecutionFlowString ( long options, const _variant_t & executionParam ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetExecutionFlowString(options, executionParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Step::GetCanCreateCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCreateCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::CreateCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::GetCanEditCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanEditCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::EditCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EditCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::CanExecuteSubstep ( long substepIndex, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanExecuteSubstep(substepIndex, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::ExecuteSubstep ( long substepIndex, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExecuteSubstep(substepIndex, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::UnloadModule ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnloadModule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

StepTypePtr Step::GetStepType ( ) {
    struct StepType * _result = 0;
    HRESULT _hr = get_StepType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepTypePtr(_result, false);
}

_bstr_t Step::GetDescriptionEx ( long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDescriptionEx(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Step::GetCancelStepCallback ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CancelStepCallback(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutCancelStepCallback ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CancelStepCallback(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr Step::GetLastStepResult ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_LastStepResult(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr Step::GetCurrentLoopResult ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_CurrentLoopResult(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr Step::GetEditSubstepMenuStructure ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetEditSubstepMenuStructure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

enum EvalPrecondOptions Step::GetEvalPrecondForInteractiveExecution ( ) {
    enum EvalPrecondOptions _result;
    HRESULT _hr = get_EvalPrecondForInteractiveExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutEvalPrecondForInteractiveExecution ( enum EvalPrecondOptions val ) {
    HRESULT _hr = put_EvalPrecondForInteractiveExecution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetIgnoreRTE ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreRTE(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutIgnoreRTE ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IgnoreRTE(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum WindowActivationOptions Step::GetWindowActivation ( ) {
    enum WindowActivationOptions _result;
    HRESULT _hr = get_WindowActivation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutWindowActivation ( enum WindowActivationOptions val ) {
    HRESULT _hr = put_WindowActivation(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetRecordLoopIterationResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RecordLoopIterationResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutRecordLoopIterationResults ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RecordLoopIterationResults(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetUseMutex ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMutex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutUseMutex ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMutex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetMutexNameOrRefExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MutexNameOrRefExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutMutexNameOrRefExpr ( _bstr_t val ) {
    HRESULT _hr = put_MutexNameOrRefExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum BatchSynchronizationOptions Step::GetBatchSyncOption ( ) {
    enum BatchSynchronizationOptions _result;
    HRESULT _hr = get_BatchSyncOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutBatchSyncOption ( enum BatchSynchronizationOptions val ) {
    HRESULT _hr = put_BatchSyncOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Step::SetBreakSettings ( VARIANT_BOOL isSet, VARIANT_BOOL enabled, long passCount, _bstr_t Condition, const _variant_t & executionParam ) {
    HRESULT _hr = raw_SetBreakSettings(isSet, enabled, passCount, Condition, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Step::GetBreakSettings ( VARIANT_BOOL * isSet, VARIANT_BOOL * enabled, long * passCount, BSTR * Condition, const _variant_t & executionParam ) {
    HRESULT _hr = raw_GetBreakSettings(isSet, enabled, passCount, Condition, executionParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Step::ChangeAdapter ( _bstr_t adapterName ) {
    HRESULT _hr = raw_ChangeAdapter(adapterName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Step::ChangeStepType ( struct StepType * stepTypePtr ) {
    HRESULT _hr = raw_ChangeStepType(stepTypePtr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Step::CanChangeAdapter ( _bstr_t adapterName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanChangeAdapter(adapterName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Step::CanChangeStepType ( struct StepType * stepTypePtr ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanChangeStepType(stepTypePtr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Step::CreateNewUniqueStepId ( ) {
    HRESULT _hr = raw_CreateNewUniqueStepId();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Step::GetUniqueStepId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UniqueStepId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

ModulePtr Step::GetModule ( ) {
    struct Module * _result = 0;
    HRESULT _hr = get_Module(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ModulePtr(_result, false);
}

VARIANT_BOOL Step::GetEditAsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EditAsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutEditAsReadOnly ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EditAsReadOnly(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Step::GetBlockLevel ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockLevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockLevelsUnmatched ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockLevelsUnmatched(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockStartIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockStartIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockEndIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockEndIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockPreviousIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockPreviousIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockNextIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockNextIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Step::GetBlockParentIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockParentIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr Step::GetRequirements ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Requirements(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

void Step::PutLastStepResult ( struct PropertyObject * val ) {
    HRESULT _hr = put_LastStepResult(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void Step::PutCurrentLoopResult ( struct PropertyObject * val ) {
    HRESULT _hr = put_CurrentLoopResult(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetStepSettingsString ( long options, struct Execution * executionParam ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetStepSettingsString(options, executionParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL Step::GetSwitchExecEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SwitchExecEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SwitchExecEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetSwitchExecVirtualDevice ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecVirtualDevice(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutSwitchExecVirtualDevice ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecVirtualDevice(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecOperations Step::GetSwitchExecOperation ( ) {
    enum SwitchExecOperations _result;
    HRESULT _hr = get_SwitchExecOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecOperation ( enum SwitchExecOperations val ) {
    HRESULT _hr = put_SwitchExecOperation(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetSwitchExecRoutesToConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecRoutesToConnect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutSwitchExecRoutesToConnect ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecRoutesToConnect(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Step::GetSwitchExecRoutesToDisconnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecRoutesToDisconnect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Step::PutSwitchExecRoutesToDisconnect ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecRoutesToDisconnect(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecMulticonnectModes Step::GetSwitchExecMulticonnectMode ( ) {
    enum SwitchExecMulticonnectModes _result;
    HRESULT _hr = get_SwitchExecMulticonnectMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecMulticonnectMode ( enum SwitchExecMulticonnectModes val ) {
    HRESULT _hr = put_SwitchExecMulticonnectMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecOperationOrders Step::GetSwitchExecOperationOrder ( ) {
    enum SwitchExecOperationOrders _result;
    HRESULT _hr = get_SwitchExecOperationOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecOperationOrder ( enum SwitchExecOperationOrders val ) {
    HRESULT _hr = put_SwitchExecOperationOrder(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecLifetimes Step::GetSwitchExecConnectionLifetime ( ) {
    enum SwitchExecLifetimes _result;
    HRESULT _hr = get_SwitchExecConnectionLifetime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecConnectionLifetime ( enum SwitchExecLifetimes val ) {
    HRESULT _hr = put_SwitchExecConnectionLifetime(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Step::GetSwitchExecWaitForDebounce ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SwitchExecWaitForDebounce(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Step::PutSwitchExecWaitForDebounce ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SwitchExecWaitForDebounce(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

StepAdditionalResultsPtr Step::GetAdditionalResults ( ) {
    struct StepAdditionalResults * _result = 0;
    HRESULT _hr = get_AdditionalResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepAdditionalResultsPtr(_result, false);
}

AdditionalResultsPtr Step::GetAdditionalResultsHints ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_AdditionalResultsHints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

VARIANT_BOOL Step::DisplayAdditionalResultsDialog ( _bstr_t dlgTitle, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayAdditionalResultsDialog(dlgTitle, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface StepType wrapper method implementations
//

PropertyObjectPtr StepType::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t StepType::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::SpecifyModule ( long specModOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SpecifyModule(specModOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL StepType::GetCanSpecifyModule ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanSpecifyModule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPictureDisp * StepType::GetMenuIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MenuIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long StepType::GetMenuIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_MenuIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t StepType::GetDefaultName ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDefaultName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

StepTypePtr StepType::CreateCombinedStepType ( struct StepType * combineWith ) {
    struct StepType * _result = 0;
    HRESULT _hr = raw_CreateCombinedStepType(combineWith, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepTypePtr(_result, false);
}

long StepType::GetNumSubsteps ( ) {
    long _result = 0;
    HRESULT _hr = get_NumSubsteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

StepPtr StepType::GetSubstep ( long substepIndex ) {
    struct Step * _result = 0;
    HRESULT _hr = raw_GetSubstep(substepIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

_bstr_t StepType::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetDefaultNameExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DefaultNameExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutDefaultNameExpr ( _bstr_t val ) {
    HRESULT _hr = put_DefaultNameExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetDescriptionExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DescriptionExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutDescriptionExpr ( _bstr_t val ) {
    HRESULT _hr = put_DescriptionExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetPrecondition ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Precondition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutPrecondition ( _bstr_t val ) {
    HRESULT _hr = put_Precondition(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetMenuItemNameExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MenuItemNameExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutMenuItemNameExpr ( _bstr_t val ) {
    HRESULT _hr = put_MenuItemNameExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetMenuGroupName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MenuGroupName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutMenuGroupName ( _bstr_t val ) {
    HRESULT _hr = put_MenuGroupName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleLoadOptions StepType::GetModuleLoadOption ( ) {
    enum ModuleLoadOptions _result;
    HRESULT _hr = get_ModuleLoadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutModuleLoadOption ( enum ModuleLoadOptions val ) {
    HRESULT _hr = put_ModuleLoadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ModuleUnloadOptions StepType::GetModuleUnloadOption ( ) {
    enum ModuleUnloadOptions _result;
    HRESULT _hr = get_ModuleUnloadOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutModuleUnloadOption ( enum ModuleUnloadOptions val ) {
    HRESULT _hr = put_ModuleUnloadOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetRunMode ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RunMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutRunMode ( _bstr_t val ) {
    HRESULT _hr = put_RunMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum EvalPrecondOptions StepType::GetEvalPrecondForInteractiveExecution ( ) {
    enum EvalPrecondOptions _result;
    HRESULT _hr = get_EvalPrecondForInteractiveExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutEvalPrecondForInteractiveExecution ( enum EvalPrecondOptions val ) {
    HRESULT _hr = put_EvalPrecondForInteractiveExecution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum WindowActivationOptions StepType::GetWindowActivation ( ) {
    enum WindowActivationOptions _result;
    HRESULT _hr = get_WindowActivation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutWindowActivation ( enum WindowActivationOptions val ) {
    HRESULT _hr = put_WindowActivation(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetRecordResult ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RecordResult(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutRecordResult ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RecordResult(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetStepFailCausesSequenceFail ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StepFailCausesSequenceFail(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutStepFailCausesSequenceFail ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StepFailCausesSequenceFail(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetIgnoreRTE ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreRTE(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutIgnoreRTE ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IgnoreRTE(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetPassAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PassAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutPassAction ( _bstr_t val ) {
    HRESULT _hr = put_PassAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetPassActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PassActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutPassActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_PassActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetFailAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FailAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutFailAction ( _bstr_t val ) {
    HRESULT _hr = put_FailAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetFailActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FailActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutFailActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_FailActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetCustomTrueAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomTrueAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutCustomTrueAction ( _bstr_t val ) {
    HRESULT _hr = put_CustomTrueAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetCustomTrueActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomTrueActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutCustomTrueActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_CustomTrueActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetCustomFalseAction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomFalseAction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutCustomFalseAction ( _bstr_t val ) {
    HRESULT _hr = put_CustomFalseAction(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetCustomFalseActionTargetByExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomFalseActionTargetByExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutCustomFalseActionTargetByExpr ( _bstr_t val ) {
    HRESULT _hr = put_CustomFalseActionTargetByExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetCustomActionExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CustomActionExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutCustomActionExpression ( _bstr_t val ) {
    HRESULT _hr = put_CustomActionExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetLoopType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutLoopType ( _bstr_t val ) {
    HRESULT _hr = put_LoopType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetLoopWhileExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopWhileExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutLoopWhileExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopWhileExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetLoopStatusExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopStatusExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutLoopStatusExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopStatusExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetLoopInitExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopInitExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutLoopInitExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopInitExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetLoopIncExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LoopIncExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutLoopIncExpression ( _bstr_t val ) {
    HRESULT _hr = put_LoopIncExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetRecordLoopIterationResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RecordLoopIterationResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutRecordLoopIterationResults ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RecordLoopIterationResults(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetUseMutex ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMutex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutUseMutex ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMutex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetMutexNameOrRefExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MutexNameOrRefExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutMutexNameOrRefExpr ( _bstr_t val ) {
    HRESULT _hr = put_MutexNameOrRefExpr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum BatchSynchronizationOptions StepType::GetBatchSyncOption ( ) {
    enum BatchSynchronizationOptions _result;
    HRESULT _hr = get_BatchSyncOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutBatchSyncOption ( enum BatchSynchronizationOptions val ) {
    HRESULT _hr = put_BatchSyncOption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetPreExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PreExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutPreExpression ( _bstr_t val ) {
    HRESULT _hr = put_PreExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetPostExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PostExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutPostExpression ( _bstr_t val ) {
    HRESULT _hr = put_PostExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetStatusExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StatusExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutStatusExpression ( _bstr_t val ) {
    HRESULT _hr = put_StatusExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * StepType::GetDimmablePropertyKeyNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_DimmablePropertyKeyNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t StepType::GetDimmablePropertyDisplayName ( _bstr_t propertyKeyName ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDimmablePropertyDisplayName(propertyKeyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL StepType::IsPropertyDimmed ( _bstr_t propertyKeyName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPropertyDimmed(propertyKeyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT StepType::DimProperty ( _bstr_t propertyKeyName, VARIANT_BOOL newValue ) {
    HRESULT _hr = raw_DimProperty(propertyKeyName, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT StepType::AddSubstep ( struct Step * newSubstep ) {
    HRESULT _hr = raw_AddSubstep(newSubstep);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT StepType::RemoveSubstep ( long substepIndex ) {
    HRESULT _hr = raw_RemoveSubstep(substepIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT StepType::SwapSubsteps ( long Index1, long index2 ) {
    HRESULT _hr = raw_SwapSubsteps(Index1, index2);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t StepType::GetDesignatedAdapter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DesignatedAdapter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT StepType::ChangeDesignatedAdapter ( _bstr_t adapterName ) {
    HRESULT _hr = raw_ChangeDesignatedAdapter(adapterName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ModulePtr StepType::GetModule ( ) {
    struct Module * _result = 0;
    HRESULT _hr = get_Module(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ModulePtr(_result, false);
}

_bstr_t StepType::GetBlockStartTypes ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BlockStartTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutBlockStartTypes ( _bstr_t val ) {
    HRESULT _hr = put_BlockStartTypes(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetBlockEndTypes ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BlockEndTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutBlockEndTypes ( _bstr_t val ) {
    HRESULT _hr = put_BlockEndTypes(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetAppliesToBlockStructure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AppliesToBlockStructure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutAppliesToBlockStructure ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AppliesToBlockStructure(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetSwitchExecEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SwitchExecEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SwitchExecEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetSwitchExecVirtualDevice ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecVirtualDevice(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutSwitchExecVirtualDevice ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecVirtualDevice(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecOperations StepType::GetSwitchExecOperation ( ) {
    enum SwitchExecOperations _result;
    HRESULT _hr = get_SwitchExecOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecOperation ( enum SwitchExecOperations val ) {
    HRESULT _hr = put_SwitchExecOperation(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetSwitchExecRoutesToConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecRoutesToConnect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutSwitchExecRoutesToConnect ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecRoutesToConnect(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StepType::GetSwitchExecRoutesToDisconnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SwitchExecRoutesToDisconnect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StepType::PutSwitchExecRoutesToDisconnect ( _bstr_t val ) {
    HRESULT _hr = put_SwitchExecRoutesToDisconnect(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecMulticonnectModes StepType::GetSwitchExecMulticonnectMode ( ) {
    enum SwitchExecMulticonnectModes _result;
    HRESULT _hr = get_SwitchExecMulticonnectMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecMulticonnectMode ( enum SwitchExecMulticonnectModes val ) {
    HRESULT _hr = put_SwitchExecMulticonnectMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecOperationOrders StepType::GetSwitchExecOperationOrder ( ) {
    enum SwitchExecOperationOrders _result;
    HRESULT _hr = get_SwitchExecOperationOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecOperationOrder ( enum SwitchExecOperationOrders val ) {
    HRESULT _hr = put_SwitchExecOperationOrder(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SwitchExecLifetimes StepType::GetSwitchExecConnectionLifetime ( ) {
    enum SwitchExecLifetimes _result;
    HRESULT _hr = get_SwitchExecConnectionLifetime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecConnectionLifetime ( enum SwitchExecLifetimes val ) {
    HRESULT _hr = put_SwitchExecConnectionLifetime(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StepType::GetSwitchExecWaitForDebounce ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SwitchExecWaitForDebounce(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StepType::PutSwitchExecWaitForDebounce ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SwitchExecWaitForDebounce(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

CodeTemplatesPtr StepType::GetCodeTemplates ( ) {
    struct CodeTemplates * _result = 0;
    HRESULT _hr = get_CodeTemplates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CodeTemplatesPtr(_result, false);
}

AdditionalResultsPtr StepType::GetAdditionalResultsHints ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_AdditionalResultsHints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

//
// interface Module wrapper method implementations
//

PropertyObjectPtr Module::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

AdapterPtr Module::GetAdapter ( ) {
    struct Adapter * _result = 0;
    HRESULT _hr = get_Adapter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdapterPtr(_result, false);
}

StepPtr Module::GetStep ( ) {
    struct Step * _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

VARIANT_BOOL Module::Load ( long loadOptions, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(loadOptions, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::Unload ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Unload(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::GetCanSpecify ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanSpecify(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::Specify ( long specModOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Specify(specModOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::GetCanCreateCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCreateCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::CreateCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::GetCanEditCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanEditCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::EditCode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EditCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Module::GetDescription ( long options ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDescription(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

UnmappedArgumentValuesPtr Module::GetUnmappedArgumentValues ( ) {
    struct UnmappedArgumentValues * _result = 0;
    HRESULT _hr = get_UnmappedArgumentValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UnmappedArgumentValuesPtr(_result, false);
}

VARIANT_BOOL Module::LoadPrototype ( long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadPrototype(options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Module::GetIsPrototypeIncompatible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPrototypeIncompatible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Module::ClearUnmappedArgumentValues ( ) {
    HRESULT _hr = raw_ClearUnmappedArgumentValues();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface UnmappedArgumentValues wrapper method implementations
//

UnmappedArgumentValuePtr UnmappedArgumentValues::GetItem ( const _variant_t & index ) {
    struct UnmappedArgumentValue * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UnmappedArgumentValuePtr(_result, false);
}

IUnknownPtr UnmappedArgumentValues::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long UnmappedArgumentValues::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface UnmappedArgumentValue wrapper method implementations
//

_bstr_t UnmappedArgumentValue::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t UnmappedArgumentValue::GetValueExpr ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValueExpr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t UnmappedArgumentValue::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

UnmappedArgumentValuesPtr UnmappedArgumentValue::GetUnmappedArgumentValues ( ) {
    struct UnmappedArgumentValues * _result = 0;
    HRESULT _hr = get_UnmappedArgumentValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UnmappedArgumentValuesPtr(_result, false);
}

//
// interface AdditionalResults wrapper method implementations
//

AdditionalResultPtr AdditionalResults::GetItem ( const _variant_t & index ) {
    struct AdditionalResult * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultPtr(_result, false);
}

IUnknownPtr AdditionalResults::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long AdditionalResults::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long AdditionalResults::GetCheckedItemCount ( ) {
    long _result = 0;
    HRESULT _hr = get_CheckedItemCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

AdditionalResultPtr AdditionalResults::Insert ( _bstr_t resultName, _bstr_t resultValueToLog, _bstr_t resultCondition, long resultFlags, long index ) {
    struct AdditionalResult * _result = 0;
    HRESULT _hr = raw_Insert(resultName, resultValueToLog, resultCondition, resultFlags, index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultPtr(_result, false);
}

AdditionalResultPtr AdditionalResults::Remove ( long index ) {
    struct AdditionalResult * _result = 0;
    HRESULT _hr = raw_Remove(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultPtr(_result, false);
}

HRESULT AdditionalResults::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT AdditionalResults::Move ( long index, long newIndex ) {
    HRESULT _hr = raw_Move(index, newIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface AdditionalResult wrapper method implementations
//

_bstr_t AdditionalResult::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void AdditionalResult::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum CheckedStates AdditionalResult::GetCheckedState ( ) {
    enum CheckedStates _result;
    HRESULT _hr = get_CheckedState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void AdditionalResult::PutCheckedState ( enum CheckedStates val ) {
    HRESULT _hr = put_CheckedState(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t AdditionalResult::GetValueToLog ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValueToLog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void AdditionalResult::PutValueToLog ( _bstr_t val ) {
    HRESULT _hr = put_ValueToLog(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t AdditionalResult::GetCondition ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void AdditionalResult::PutCondition ( _bstr_t val ) {
    HRESULT _hr = put_Condition(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long AdditionalResult::GetFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_Flags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void AdditionalResult::PutFlags ( long val ) {
    HRESULT _hr = put_Flags(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL AdditionalResult::GetIsAnyType ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAnyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void AdditionalResult::PutIsAnyType ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IsAnyType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

AdditionalResultsPtr AdditionalResult::GetElements ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_Elements(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

PropertyObjectTypePtr AdditionalResult::GetType ( ) {
    struct PropertyObjectType * _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectTypePtr(_result, false);
}

void AdditionalResult::PutType ( struct PropertyObjectType * val ) {
    HRESULT _hr = put_Type(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

AdditionalResultPtr AdditionalResult::GetParentAdditionalResult ( ) {
    struct AdditionalResult * _result = 0;
    HRESULT _hr = get_ParentAdditionalResult(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultPtr(_result, false);
}

VARIANT_BOOL AdditionalResult::GetAreElementsIncompatibleWithType ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AreElementsIncompatibleWithType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

AdditionalResultsPtr AdditionalResult::GetUnmappedAdditionalResults ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_UnmappedAdditionalResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

//
// interface StepAdditionalResults wrapper method implementations
//

AdditionalResultsPtr StepAdditionalResults::GetParameterResults ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_ParameterResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

AdditionalResultsPtr StepAdditionalResults::GetCustomResults ( ) {
    struct AdditionalResults * _result = 0;
    HRESULT _hr = get_CustomResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdditionalResultsPtr(_result, false);
}

//
// interface Execution wrapper method implementations
//

HRESULT Execution::Break ( ) {
    HRESULT _hr = raw_Break();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::Resume ( ) {
    HRESULT _hr = raw_Resume();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::StepOver ( ) {
    HRESULT _hr = raw_StepOver();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::StepInto ( ) {
    HRESULT _hr = raw_StepInto();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::StepOut ( ) {
    HRESULT _hr = raw_StepOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::Abort ( ) {
    HRESULT _hr = raw_Abort();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::Terminate ( ) {
    HRESULT _hr = raw_Terminate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::TerminateInteractiveExecution ( ) {
    HRESULT _hr = raw_TerminateInteractiveExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::CancelTermination ( ) {
    HRESULT _hr = raw_CancelTermination();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::Restart ( VARIANT_BOOL breakOnEntryParam ) {
    HRESULT _hr = raw_Restart(breakOnEntryParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Execution::WaitForEnd ( long millisecondTimeOut, VARIANT_BOOL processWindowsMsgs, const _variant_t & callingExecution ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_WaitForEnd(millisecondTimeOut, processWindowsMsgs, callingExecution, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ThreadPtr Execution::GetThread ( long index ) {
    struct Thread * _result = 0;
    HRESULT _hr = raw_GetThread(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadPtr(_result, false);
}

SequenceFilePtr Execution::GetSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetSequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

SequenceFilePtr Execution::GetModelSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = raw_GetModelSequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

HRESULT Execution::AddExtraResult ( _bstr_t propertyName, _bstr_t resultPropertyName ) {
    HRESULT _hr = raw_AddExtraResult(propertyName, resultPropertyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::DeleteExtraResult ( _bstr_t propertyName ) {
    HRESULT _hr = raw_DeleteExtraResult(propertyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::ClearExtraResultList ( ) {
    HRESULT _hr = raw_ClearExtraResultList();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::GetStates ( enum ExecutionRunStates * runState, enum ExecutionTerminationStates * termState ) {
    HRESULT _hr = raw_GetStates(runState, termState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr Execution::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL Execution::GetInInteractiveMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InInteractiveMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Execution::GetTypeMask ( ) {
    long _result = 0;
    HRESULT _hr = get_TypeMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Execution::GetBreakOnRTEForThisExecution ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnRTEForThisExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutBreakOnRTEForThisExecution ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BreakOnRTEForThisExecution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Execution::GetNumThreads ( ) {
    long _result = 0;
    HRESULT _hr = get_NumThreads(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Execution::GetForegroundThreadIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_ForegroundThreadIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutForegroundThreadIndex ( long val ) {
    HRESULT _hr = put_ForegroundThreadIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePreStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePreStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePreStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePreStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePostStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePostStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePostStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePostStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPreStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPreStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPreStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPreStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPostStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPostStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPostStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPostStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPreStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPreStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPreStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPreStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPostStepCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPostStepCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPostStepCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPostStepCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePreInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePreInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePreInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePreInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePostInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePostInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePostInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePostInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPreInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPreInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPreInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPreInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPostInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPostInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPostInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPostInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPreInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPreInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPreInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPreInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPostInteractiveCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPostInteractiveCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPostInteractiveCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPostInteractiveCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetTimeResultsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TimeResultsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutTimeResultsEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_TimeResultsEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStandardResultsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StandardResultsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStandardResultsEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StandardResultsEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPostResultCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPostResultCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPostResultCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPostResultCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPostResultCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPostResultCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPostResultCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPostResultCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePostResultCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePostResultCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePostResultCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePostResultCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPostErrorCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPostErrorCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPostErrorCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPostErrorCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPostErrorCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPostErrorCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPostErrorCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPostErrorCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePostErrorCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePostErrorCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePostErrorCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePostErrorCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetStationPostFailCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StationPostFailCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutStationPostFailCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StationPostFailCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetModelPostFailCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ModelPostFailCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutModelPostFailCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ModelPostFailCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetSeqFilePostFailCallbackEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeqFilePostFailCallbackEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutSeqFilePostFailCallbackEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeqFilePostFailCallbackEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetDisableResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DisableResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutDisableResults ( VARIANT_BOOL val ) {
    HRESULT _hr = put_DisableResults(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Execution::GetResultStatus ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ResultStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Execution::PutResultStatus ( _bstr_t val ) {
    HRESULT _hr = put_ResultStatus(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectPtr Execution::GetErrorObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_ErrorObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

ReportPtr Execution::GetReport ( ) {
    struct Report * _result = 0;
    HRESULT _hr = get_Report(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportPtr(_result, false);
}

long Execution::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t Execution::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

PropertyObjectPtr Execution::GetResultObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_ResultObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t Execution::GetSequenceFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t Execution::GetModelSequenceFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ModelSequenceFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT Execution::ClearTemporaryBreakpoints ( ) {
    HRESULT _hr = raw_ClearTemporaryBreakpoints();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double Execution::GetSecondsExecuting ( ) {
    double _result = 0;
    HRESULT _hr = get_SecondsExecuting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double Execution::GetSecondsSuspended ( ) {
    double _result = 0;
    HRESULT _hr = get_SecondsSuspended(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double Execution::GetSecondsAtStart ( ) {
    double _result = 0;
    HRESULT _hr = get_SecondsAtStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Execution::GetFileGlobals ( struct SequenceFile * sequenceFileParam ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_GetFileGlobals(sequenceFileParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

ThreadPtr Execution::GetForegroundThread ( ) {
    struct Thread * _result = 0;
    HRESULT _hr = get_ForegroundThread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadPtr(_result, false);
}

void Execution::PutForegroundThread ( struct Thread * val ) {
    HRESULT _hr = put_ForegroundThread(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void Execution::PutRefForegroundThread ( struct Thread * val ) {
    HRESULT _hr = putref_ForegroundThread(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Execution::RestartEx ( long restartOptionsParam ) {
    HRESULT _hr = raw_RestartEx(restartOptionsParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequenceFilePtr Execution::GetClientFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_ClientFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

void Execution::PutClientFile ( struct SequenceFile * val ) {
    HRESULT _hr = put_ClientFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void Execution::PutRefClientFile ( struct SequenceFile * val ) {
    HRESULT _hr = putref_ClientFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::GetTracingDisabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TracingDisabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutTracingDisabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_TracingDisabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum RTEOptions Execution::GetRTEOptionForThisExecution ( ) {
    enum RTEOptions _result;
    HRESULT _hr = get_RTEOptionForThisExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Execution::PutRTEOptionForThisExecution ( enum RTEOptions val ) {
    HRESULT _hr = put_RTEOptionForThisExecution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Execution::WaitForEndEx ( long millisecondTimeOut, VARIANT_BOOL processWindowsMsgs, const _variant_t & stepToStoreResultsIn, const _variant_t & callingSequenceContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_WaitForEndEx(millisecondTimeOut, processWindowsMsgs, stepToStoreResultsIn, callingSequenceContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Execution::GetBreakOnEntry ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnEntry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Execution::GetStartCount ( ) {
    long _result = 0;
    HRESULT _hr = get_StartCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Execution::InitTerminationMonitor ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_InitTerminationMonitor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

VARIANT_BOOL Execution::GetTerminationMonitorStatus ( struct PropertyObject * terminationMonitorData, const _variant_t & sequenceContextParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetTerminationMonitorStatus(terminationMonitorData, sequenceContextParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Execution::GetRunTimeVariables ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_RunTimeVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT Execution::AddPostStepCustomUIMessage ( long MsgCode, _bstr_t Expression, long CustomUIMessageOptions ) {
    HRESULT _hr = raw_AddPostStepCustomUIMessage(MsgCode, Expression, CustomUIMessageOptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::RemovePostStepCustomUIMessage ( long MsgCode ) {
    HRESULT _hr = raw_RemovePostStepCustomUIMessage(MsgCode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::EnableCallback ( enum CallbackTypes callbackType, VARIANT_BOOL newValue ) {
    HRESULT _hr = raw_EnableCallback(callbackType, newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Execution::IsCallbackEnabled ( enum CallbackTypes callbackType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsCallbackEnabled(callbackType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequencePtr Execution::NewSequenceDefaultValues ( struct Sequence * origSequence ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_NewSequenceDefaultValues(origSequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

SequencePtr Execution::GetSequenceDefaultValues ( struct Sequence * origSequence, enum SequenceDefaultValueScopes defaultValueType ) {
    struct Sequence * _result = 0;
    HRESULT _hr = raw_GetSequenceDefaultValues(origSequence, defaultValueType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

HRESULT Execution::SetSequenceDefaultValues ( struct Sequence * defValSequence, enum SequenceDefaultValueScopes defaultValueType ) {
    HRESULT _hr = raw_SetSequenceDefaultValues(defValSequence, defaultValueType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Execution::ClearSequenceDefaultValues ( struct Sequence * origSequence, enum SequenceDefaultValueScopes defaultValueType ) {
    HRESULT _hr = raw_ClearSequenceDefaultValues(origSequence, defaultValueType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

void Execution::PutTypeMask ( long val ) {
    HRESULT _hr = put_TypeMask(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ThreadPtr Execution::NewThread ( struct SequenceFile * sequenceFileParam, _bstr_t sequenceNameParam, long options, struct SequenceContext * sequenceContextParam, struct PropertyObject * sequenceArgsParam ) {
    struct Thread * _result = 0;
    HRESULT _hr = raw_NewThread(sequenceFileParam, sequenceNameParam, options, sequenceContextParam, sequenceArgsParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadPtr(_result, false);
}

//
// interface EditArgs wrapper method implementations
//

HRESULT EditArgs::SetSelectedSequenceFile ( struct SequenceFile * SequenceFile ) {
    HRESULT _hr = raw_SetSelectedSequenceFile(SequenceFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::AddSelectedSequence ( struct Sequence * Sequence ) {
    HRESULT _hr = raw_AddSelectedSequence(Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::AddSelectedStep ( struct Step * Step ) {
    HRESULT _hr = raw_AddSelectedStep(Step);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::ClearSelectedSequences ( ) {
    HRESULT _hr = raw_ClearSelectedSequences();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::ClearSelectedSteps ( ) {
    HRESULT _hr = raw_ClearSelectedSteps();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::SetSelectedExecution ( struct Execution * Execution ) {
    HRESULT _hr = raw_SetSelectedExecution(Execution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::SetSelectedStepGroup ( enum StepGroups stepGroupParam ) {
    HRESULT _hr = raw_SetSelectedStepGroup(stepGroupParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::SetSelectedPropertyObjectFile ( struct PropertyObjectFile * propertyFile ) {
    HRESULT _hr = raw_SetSelectedPropertyObjectFile(propertyFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr EditArgs::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT EditArgs::AddSelectedPropertyObject ( struct PropertyObject * propertyToAdd ) {
    HRESULT _hr = raw_AddSelectedPropertyObject(propertyToAdd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditArgs::ClearSelectedPropertyObjects ( ) {
    HRESULT _hr = raw_ClearSelectedPropertyObjects();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface RExecutor wrapper method implementations
//

HRESULT RExecutor::LoadModule ( _bstr_t modulePath ) {
    HRESULT _hr = raw_LoadModule(modulePath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ExecutionPtr RExecutor::Execute ( _bstr_t modulePath, _bstr_t seqName, VARIANT_BOOL trace, const _variant_t & args ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_Execute(modulePath, seqName, trace, args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

HRESULT RExecutor::UnloadModule ( _bstr_t modulePath ) {
    HRESULT _hr = raw_UnloadModule(modulePath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr RExecutor::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long RExecutor::GetExecutorType ( ) {
    long _result = 0;
    HRESULT _hr = get_ExecutorType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Thread wrapper method implementations
//

HRESULT Thread::ClearTemporaryBreakpoint ( ) {
    HRESULT _hr = raw_ClearTemporaryBreakpoint();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::SetStepOver ( ) {
    HRESULT _hr = raw_SetStepOver();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::SetStepInto ( ) {
    HRESULT _hr = raw_SetStepInto();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::SetStepOut ( ) {
    HRESULT _hr = raw_SetStepOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SequenceContextPtr Thread::GetSequenceContext ( long callStackIndex, long * frameId ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = raw_GetSequenceContext(callStackIndex, frameId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

HRESULT Thread::ClearCurrentRTE ( ) {
    HRESULT _hr = raw_ClearCurrentRTE();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::DoInteractiveExecution ( struct InteractiveArgs * InteractiveArgsParam ) {
    HRESULT _hr = raw_DoInteractiveExecution(InteractiveArgsParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::PostUIMessage ( enum UIMessageCodes eventCode, double numericDataParam, _bstr_t stringDataParam, VARIANT_BOOL synchronous ) {
    HRESULT _hr = raw_PostUIMessage(eventCode, numericDataParam, stringDataParam, synchronous);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL Thread::WaitForEnd ( long millisecondTimeOut, VARIANT_BOOL processWindowsMsgs, const _variant_t & stepToStoreResultsIn, const _variant_t & callingSequenceContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_WaitForEnd(millisecondTimeOut, processWindowsMsgs, stepToStoreResultsIn, callingSequenceContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr Thread::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t Thread::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

ExecutionPtr Thread::GetExecution ( ) {
    struct Execution * _result = 0;
    HRESULT _hr = get_Execution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

long Thread::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Thread::GetCallStackSize ( ) {
    long _result = 0;
    HRESULT _hr = get_CallStackSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL Thread::GetExternallySuspended ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExternallySuspended(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Thread::PutExternallySuspended ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ExternallySuspended(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Thread::PostUIMessageEx ( enum UIMessageCodes eventCode, double numericDataParam, _bstr_t stringDataParam, IUnknown * activeXDataParam, VARIANT_BOOL synchronous ) {
    HRESULT _hr = raw_PostUIMessageEx(eventCode, numericDataParam, stringDataParam, activeXDataParam, synchronous);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IUnknownPtr Thread::GetBatch ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get_Batch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT Thread::AddToBatch ( IUnknown * batchObj, long orderNumber ) {
    HRESULT _hr = raw_AddToBatch(batchObj, orderNumber);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Thread::Resume ( ) {
    HRESULT _hr = raw_Resume();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Thread::GetUniqueThreadId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UniqueThreadId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT Thread::SetBatchRTEOption ( enum RTEOptions newValue ) {
    HRESULT _hr = raw_SetBatchRTEOption(newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

PropertyObjectPtr Thread::GetRunTimeVariables ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_RunTimeVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

//
// interface SequenceContext wrapper method implementations
//

VARIANT_BOOL SequenceContext::IsInteractiveStep ( long stepIndexParam ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsInteractiveStep(stepIndexParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr SequenceContext::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

StepPtr SequenceContext::GetStep ( ) {
    struct Step * _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

StepPtr SequenceContext::GetPreviousStep ( ) {
    struct Step * _result = 0;
    HRESULT _hr = get_PreviousStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

StepPtr SequenceContext::GetNextStep ( ) {
    struct Step * _result = 0;
    HRESULT _hr = get_NextStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

SequencePtr SequenceContext::GetSequence ( ) {
    struct Sequence * _result = 0;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequencePtr(_result, false);
}

SequenceFilePtr SequenceContext::GetSequenceFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_SequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

long SequenceContext::GetStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_StepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceContext::GetPreviousStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_PreviousStepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceContext::GetNextStepIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_NextStepIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutNextStepIndex ( long val ) {
    HRESULT _hr = put_NextStepIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetSequenceIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SequenceIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum StepGroups SequenceContext::GetStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequenceContextPtr SequenceContext::GetCaller ( ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = get_Caller(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

_bstr_t SequenceContext::GetCallStackName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CallStackName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t SequenceContext::GetRunTimeErrorMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RunTimeErrorMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL SequenceContext::GetStepGroupStartedInteractiveExe ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StepGroupStartedInteractiveExe(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceContext::GetInInteractiveMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InInteractiveMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

InteractiveContextPtr SequenceContext::GetInteractiveContext ( ) {
    struct InteractiveContext * _result = 0;
    HRESULT _hr = get_InteractiveContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InteractiveContextPtr(_result, false);
}

SequenceContextPtr SequenceContext::GetRoot ( ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = get_Root(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

SequenceContextPtr SequenceContext::GetMain ( ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = get_Main(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

ThreadPtr SequenceContext::GetThread ( ) {
    struct Thread * _result = 0;
    HRESULT _hr = get_Thread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadPtr(_result, false);
}

ExecutionPtr SequenceContext::GetExecution ( ) {
    struct Execution * _result = 0;
    HRESULT _hr = get_Execution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

ReportPtr SequenceContext::GetReport ( ) {
    struct Report * _result = 0;
    HRESULT _hr = get_Report(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportPtr(_result, false);
}

SequenceFilePtr SequenceContext::GetProcessModelClient ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_ProcessModelClient(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

SequenceFilePtr SequenceContext::GetSelectedFile ( ) {
    struct SequenceFile * _result = 0;
    HRESULT _hr = get_SelectedFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilePtr(_result, false);
}

ExecutionPtr SequenceContext::GetSelectedExecution ( ) {
    struct Execution * _result = 0;
    HRESULT _hr = get_SelectedExecution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

PropertyObjectPtr SequenceContext::GetLocals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Locals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr SequenceContext::GetParameters ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_Parameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr SequenceContext::GetFileGlobals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_FileGlobals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr SequenceContext::GetStationGlobals ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_StationGlobals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

long SequenceContext::GetCallStackDepth ( ) {
    long _result = 0;
    HRESULT _hr = get_CallStackDepth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceContext::GetLoopIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_LoopIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutLoopIndex ( long val ) {
    HRESULT _hr = put_LoopIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IEnginePtr SequenceContext::GetEngine ( ) {
    struct IEngine * _result = 0;
    HRESULT _hr = get_Engine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnginePtr(_result, false);
}

long SequenceContext::GetLoopNumPassed ( ) {
    long _result = 0;
    HRESULT _hr = get_LoopNumPassed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutLoopNumPassed ( long val ) {
    HRESULT _hr = put_LoopNumPassed(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetLoopNumFailed ( ) {
    long _result = 0;
    HRESULT _hr = get_LoopNumFailed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutLoopNumFailed ( long val ) {
    HRESULT _hr = put_LoopNumFailed(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceContext::GetIsProcessModel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsProcessModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceContext::GetTracing ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Tracing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutTracing ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Tracing(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceContext::GetSequenceFailed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SequenceFailed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutSequenceFailed ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SequenceFailed(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t SequenceContext::GetSelectedSequences ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_SelectedSequences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t SequenceContext::GetSelectedSteps ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_SelectedSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

VARIANT_BOOL SequenceContext::GetApplicationIsEditor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ApplicationIsEditor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceContext::GetGotoCleanup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GotoCleanup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutGotoCleanup ( VARIANT_BOOL val ) {
    HRESULT _hr = put_GotoCleanup(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IDispatchPtr SequenceContext::GetEngineAsDispatch ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_EngineAsDispatch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

void SequenceContext::PutStepGroup ( enum StepGroups val ) {
    HRESULT _hr = put_StepGroup(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL SequenceContext::IsStepExcludedFromExecution ( struct Step * Step ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsStepExcludedFromExecution(Step, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceContext::GetRunTimeErrorMessageEx ( BSTR * detailsMsg, BSTR * errorCodeMsg, BSTR * locationMsg ) {
    HRESULT _hr = raw_GetRunTimeErrorMessageEx(detailsMsg, errorCodeMsg, locationMsg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

void SequenceContext::PutStepIndex ( long val ) {
    HRESULT _hr = put_StepIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void SequenceContext::PutPreviousStepIndex ( long val ) {
    HRESULT _hr = put_PreviousStepIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

StepPtr SequenceContext::GetCallingStep ( ) {
    struct Step * _result = 0;
    HRESULT _hr = get_CallingStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepPtr(_result, false);
}

_bstr_t SequenceContext::GetSequenceErrorMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceErrorMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SequenceContext::PutSequenceErrorMessage ( _bstr_t val ) {
    HRESULT _hr = put_SequenceErrorMessage(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetSequenceErrorCode ( ) {
    long _result = 0;
    HRESULT _hr = get_SequenceErrorCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutSequenceErrorCode ( long errorCode ) {
    HRESULT _hr = put_SequenceErrorCode(errorCode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceContext::GetSequenceErrorOccurred ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SequenceErrorOccurred(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutSequenceErrorOccurred ( VARIANT_BOOL occurredFlag ) {
    HRESULT _hr = put_SequenceErrorOccurred(occurredFlag);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SequenceContext::GetErrorReported ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ErrorReported(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutErrorReported ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ErrorReported(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum StepGroups SequenceContext::GetSelectedStepGroup ( ) {
    enum StepGroups _result;
    HRESULT _hr = get_SelectedStepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutSelectedStepGroup ( enum StepGroups StepGroup ) {
    HRESULT _hr = put_SelectedStepGroup(StepGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

PropertyObjectFilePtr SequenceContext::GetSelectedPropertyObjectFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_SelectedPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

VARIANT_BOOL SequenceContext::GetCallerDiscardsResults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CallerDiscardsResults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceContext::GetRunTimeErrorWinHelpInfo ( long * winHelpID, BSTR * winHelpFile ) {
    HRESULT _hr = raw_GetRunTimeErrorWinHelpInfo(winHelpID, winHelpFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t SequenceContext::GetSelectedPropertyObjects ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_SelectedPropertyObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

long SequenceContext::GetLoopNumIterations ( ) {
    long _result = 0;
    HRESULT _hr = get_LoopNumIterations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutLoopNumIterations ( long val ) {
    HRESULT _hr = put_LoopNumIterations(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetNumStepsExecuted ( ) {
    long _result = 0;
    HRESULT _hr = get_NumStepsExecuted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SequenceContext::PutNumStepsExecuted ( long val ) {
    HRESULT _hr = put_NumStepsExecuted(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SequenceContext::GetMultipleValues ( _bstr_t lookupString, enum PropertyObjectElements elem ) {
    long _result = 0;
    HRESULT _hr = raw_GetMultipleValues(lookupString, elem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceContext::SetMultipleValues ( _bstr_t lookupString, enum PropertyObjectElements elem, long multipleValues ) {
    HRESULT _hr = raw_SetMultipleValues(lookupString, elem, multipleValues);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ExecutionPtr SequenceContext::NewExecution ( struct SequenceFile * sequenceFileParam, _bstr_t sequenceNameParam, struct SequenceFile * processModelParam, VARIANT_BOOL breakAtFirstStep, VARIANT_BOOL synchronous, long executionTypeMaskParam, struct PropertyObject * sequenceArgsParam ) {
    struct Execution * _result = 0;
    HRESULT _hr = raw_NewExecution(sequenceFileParam, sequenceNameParam, processModelParam, breakAtFirstStep, synchronous, executionTypeMaskParam, sequenceArgsParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

void SequenceContext::PutProcessModelClient ( struct SequenceFile * val ) {
    HRESULT _hr = put_ProcessModelClient(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface UIMessage wrapper method implementations
//

PropertyObjectPtr UIMessage::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

enum UIMessageCodes UIMessage::GetEvent ( ) {
    enum UIMessageCodes _result;
    HRESULT _hr = get_Event(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL UIMessage::GetIsSynchronous ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSynchronous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ExecutionPtr UIMessage::GetExecution ( ) {
    struct Execution * _result = 0;
    HRESULT _hr = get_Execution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

ThreadPtr UIMessage::GetThread ( ) {
    struct Thread * _result = 0;
    HRESULT _hr = get_Thread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadPtr(_result, false);
}

double UIMessage::GetNumericData ( ) {
    double _result = 0;
    HRESULT _hr = get_NumericData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t UIMessage::GetStringData ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StringData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IUnknownPtr UIMessage::GetActiveXData ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get_ActiveXData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT UIMessage::Acknowledge ( ) {
    HRESULT _hr = raw_Acknowledge();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface WatchExpression wrapper method implementations
//

PropertyObjectPtr WatchExpression::Evaluate ( struct SequenceContext * seqContext, long reserved ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_Evaluate(seqContext, reserved, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t WatchExpression::GetClientSequenceFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClientSequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WatchExpression::PutClientSequenceFile ( _bstr_t clientFileNameParam ) {
    HRESULT _hr = put_ClientSequenceFile(clientFileNameParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WatchExpression::GetSequenceFileScope ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceFileScope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WatchExpression::PutSequenceFileScope ( _bstr_t sequenceFileNameParam ) {
    HRESULT _hr = put_SequenceFileScope(sequenceFileNameParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WatchExpression::GetSequenceScope ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceScope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WatchExpression::PutSequenceScope ( _bstr_t sequenceNameParam ) {
    HRESULT _hr = put_SequenceScope(sequenceNameParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ExecutionPtr WatchExpression::GetExecutionScope ( ) {
    struct Execution * _result = 0;
    HRESULT _hr = get_ExecutionScope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionPtr(_result, false);
}

void WatchExpression::PutRefExecutionScope ( struct Execution * execParam ) {
    HRESULT _hr = putref_ExecutionScope(execParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WatchExpression::GetExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Expression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WatchExpression::PutExpression ( _bstr_t val ) {
    HRESULT _hr = put_Expression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WatchExpression::GetNumericFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_NumericFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void WatchExpression::PutNumericFormat ( _bstr_t val ) {
    HRESULT _hr = put_NumericFormat(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum WatchExpressionBreakType WatchExpression::GetBreakpointType ( ) {
    enum WatchExpressionBreakType _result;
    HRESULT _hr = get_BreakpointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void WatchExpression::PutBreakpointType ( enum WatchExpressionBreakType val ) {
    HRESULT _hr = put_BreakpointType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t WatchExpression::GetUniqueWatchId ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UniqueWatchId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL WatchExpression::BreakpointTriggered ( struct SequenceContext * seqContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_BreakpointTriggered(seqContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL WatchExpression::DisplayConfigurationDialog ( _bstr_t dlgTitle, struct SequenceContext * context, long dlgOptions ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayConfigurationDialog(dlgTitle, context, dlgOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL WatchExpression::GetUseScopingContext ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScopingContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void WatchExpression::PutUseScopingContext ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseScopingContext(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SequenceContextPtr WatchExpression::GetScopingContext ( struct SequenceContext * currentSeqContext ) {
    struct SequenceContext * _result = 0;
    HRESULT _hr = raw_GetScopingContext(currentSeqContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceContextPtr(_result, false);
}

//
// interface WatchExpressions wrapper method implementations
//

WatchExpressionPtr WatchExpressions::GetItem ( const _variant_t & index ) {
    struct WatchExpression * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WatchExpressionPtr(_result, false);
}

IUnknownPtr WatchExpressions::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long WatchExpressions::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

WatchExpressionPtr WatchExpressions::Insert ( struct WatchExpression * beforePos, const _variant_t & clientSequenceFileParam, const _variant_t & insertInEngine ) {
    struct WatchExpression * _result = 0;
    HRESULT _hr = raw_Insert(beforePos, clientSequenceFileParam, insertInEngine, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WatchExpressionPtr(_result, false);
}

HRESULT WatchExpressions::Remove ( struct WatchExpression * WatchExpression ) {
    HRESULT _hr = raw_Remove(WatchExpression);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT WatchExpressions::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

WatchExpressionsPtr WatchExpressions::Clone ( const _variant_t & insertInEngine ) {
    struct WatchExpressions * _result = 0;
    HRESULT _hr = raw_Clone(insertInEngine, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WatchExpressionsPtr(_result, false);
}

//
// interface Locations wrapper method implementations
//

LocationPtr Locations::GetItem ( long index ) {
    struct Location * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

IUnknownPtr Locations::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long Locations::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

LocationPtr Locations::AddFileLocation ( struct PropertyObjectFile * file, _bstr_t lookupString, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddFileLocation(file, lookupString, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

LocationPtr Locations::AddFileLocationByObject ( struct PropertyObject * obj, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddFileLocationByObject(obj, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

LocationPtr Locations::AddExecutionLocation ( struct SequenceContext * seqContext, _bstr_t lookupString, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddExecutionLocation(seqContext, lookupString, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

LocationPtr Locations::AddExecutionLocationByObject ( struct SequenceContext * seqContext, struct PropertyObject * obj, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddExecutionLocationByObject(seqContext, obj, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

LocationPtr Locations::AddTypeLocation ( struct PropertyObjectFile * file, struct PropertyObject * rootTypeDef, _bstr_t lookupString, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddTypeLocation(file, rootTypeDef, lookupString, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

LocationPtr Locations::AddTypeLocationByObject ( struct PropertyObjectFile * file, struct PropertyObject * obj, enum PropertyObjectElements elem, long selectionStart, long selectionLength ) {
    struct Location * _result = 0;
    HRESULT _hr = raw_AddTypeLocationByObject(file, obj, elem, selectionStart, selectionLength, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationPtr(_result, false);
}

HRESULT Locations::AddLocations ( struct Locations * locationsToAdd, enum CopyLocationsOptions copyLocationOption ) {
    HRESULT _hr = raw_AddLocations(locationsToAdd, copyLocationOption);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Locations::Remove ( long index ) {
    HRESULT _hr = raw_Remove(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Locations::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Locations::GotoLocation ( long options ) {
    HRESULT _hr = raw_GotoLocation(options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t Locations::GetUserData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void Locations::PutUserData ( const _variant_t & val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ApplicationSites Locations::GetApplicationSite ( ) {
    enum ApplicationSites _result;
    HRESULT _hr = get_ApplicationSite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Locations::PutApplicationSite ( enum ApplicationSites val ) {
    HRESULT _hr = put_ApplicationSite(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Locations::GetLocationFound ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LocationFound(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Locations::PutLocationFound ( VARIANT_BOOL val ) {
    HRESULT _hr = put_LocationFound(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Locations::GetLocationNotFoundMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LocationNotFoundMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Locations::PutLocationNotFoundMessage ( _bstr_t val ) {
    HRESULT _hr = put_LocationNotFoundMessage(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Locations::GetCanDisplayDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanDisplayDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Locations::PutCanDisplayDialog ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CanDisplayDialog(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface OutputMessage wrapper method implementations
//

_bstr_t OutputMessage::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void OutputMessage::PutCategory ( _bstr_t val ) {
    HRESULT _hr = put_Category(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum OutputMessageSeverityTypes OutputMessage::GetSeverity ( ) {
    enum OutputMessageSeverityTypes _result;
    HRESULT _hr = get_Severity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void OutputMessage::PutSeverity ( enum OutputMessageSeverityTypes val ) {
    HRESULT _hr = put_Severity(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t OutputMessage::GetMessage ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Message(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void OutputMessage::PutMessage ( _bstr_t val ) {
    HRESULT _hr = put_Message(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR OutputMessage::GetTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void OutputMessage::PutTextColor ( OLE_COLOR val ) {
    HRESULT _hr = put_TextColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

DATE OutputMessage::GetTimeStamp ( ) {
    DATE _result = 0;
    HRESULT _hr = get_TimeStamp(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void OutputMessage::PutTimeStamp ( DATE val ) {
    HRESULT _hr = put_TimeStamp(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t OutputMessage::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void OutputMessage::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

LocationsPtr OutputMessage::GetFileLocations ( ) {
    struct Locations * _result = 0;
    HRESULT _hr = get_FileLocations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationsPtr(_result, false);
}

HRESULT OutputMessage::Post ( ) {
    HRESULT _hr = raw_Post();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

LocationsPtr OutputMessage::GetExecutionLocations ( ) {
    struct Locations * _result = 0;
    HRESULT _hr = get_ExecutionLocations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationsPtr(_result, false);
}

double OutputMessage::GetTimeInSeconds ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeInSeconds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void OutputMessage::PutTimeInSeconds ( double val ) {
    HRESULT _hr = put_TimeInSeconds(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long OutputMessage::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr OutputMessage::AsPropertyObject ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_AsPropertyObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

//
// interface OutputMessages wrapper method implementations
//

OutputMessagePtr OutputMessages::GetItem ( const _variant_t & index ) {
    struct OutputMessage * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return OutputMessagePtr(_result, false);
}

IUnknownPtr OutputMessages::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long OutputMessages::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT OutputMessages::Add ( struct OutputMessage * OutputMessage ) {
    HRESULT _hr = raw_Add(OutputMessage);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT OutputMessages::Remove ( long index ) {
    HRESULT _hr = raw_Remove(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT OutputMessages::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT OutputMessages::TransferMessagesToCollection ( struct OutputMessages * target ) {
    HRESULT _hr = raw_TransferMessagesToCollection(target);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT OutputMessages::CopyMessagesToCollection ( struct OutputMessages * target ) {
    HRESULT _hr = raw_CopyMessagesToCollection(target);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long OutputMessages::FindIndex ( long outputMessageId ) {
    long _result = 0;
    HRESULT _hr = raw_FindIndex(outputMessageId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr OutputMessages::ToPropertyObject ( VARIANT_BOOL storeExecutionLocations ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = raw_ToPropertyObject(storeExecutionLocations, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

HRESULT OutputMessages::FromPropertyObject ( struct PropertyObject * val ) {
    HRESULT _hr = raw_FromPropertyObject(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface EditTimeMenuItems wrapper method implementations
//

EditTimeMenuItemPtr EditTimeMenuItems::GetItem ( const _variant_t & index ) {
    struct EditTimeMenuItem * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EditTimeMenuItemPtr(_result, false);
}

IUnknownPtr EditTimeMenuItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long EditTimeMenuItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

EditTimeMenuItemPtr EditTimeMenuItems::Insert ( enum ToolMenuTypes Type, long index ) {
    struct EditTimeMenuItem * _result = 0;
    HRESULT _hr = raw_Insert(Type, index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EditTimeMenuItemPtr(_result, false);
}

HRESULT EditTimeMenuItems::Remove ( long index ) {
    HRESULT _hr = raw_Remove(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT EditTimeMenuItems::MoveItem ( long index, long newIndex ) {
    HRESULT _hr = raw_MoveItem(index, newIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface EditTimeMenuItem wrapper method implementations
//

enum ToolMenuTypes EditTimeMenuItem::GetType ( ) {
    enum ToolMenuTypes _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EditTimeMenuItem::PutType ( enum ToolMenuTypes val ) {
    HRESULT _hr = put_Type(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetItemTextExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ItemTextExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutItemTextExpression ( _bstr_t val ) {
    HRESULT _hr = put_ItemTextExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetEnabledExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EnabledExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutEnabledExpression ( _bstr_t val ) {
    HRESULT _hr = put_EnabledExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetHiddenExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HiddenExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutHiddenExpression ( _bstr_t val ) {
    HRESULT _hr = put_HiddenExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL EditTimeMenuItem::GetSeparatorBefore ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeparatorBefore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EditTimeMenuItem::PutSeparatorBefore ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SeparatorBefore(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetSequenceFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutSequenceFilePath ( _bstr_t val ) {
    HRESULT _hr = put_SequenceFilePath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetSequenceName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SequenceName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutSequenceName ( _bstr_t val ) {
    HRESULT _hr = put_SequenceName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL EditTimeMenuItem::GetEditsSelectedFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EditsSelectedFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EditTimeMenuItem::PutEditsSelectedFile ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EditsSelectedFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetCommandPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CommandPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutCommandPath ( _bstr_t val ) {
    HRESULT _hr = put_CommandPath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetCommandArguments ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CommandArguments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutCommandArguments ( _bstr_t val ) {
    HRESULT _hr = put_CommandArguments(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t EditTimeMenuItem::GetCommandInitialDirectory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CommandInitialDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void EditTimeMenuItem::PutCommandInitialDirectory ( _bstr_t val ) {
    HRESULT _hr = put_CommandInitialDirectory(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL EditTimeMenuItem::GetEditable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Editable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void EditTimeMenuItem::PutEditable ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Editable(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

EditTimeMenuItemsPtr EditTimeMenuItem::GetSubMenuItems ( ) {
    struct EditTimeMenuItems * _result = 0;
    HRESULT _hr = get_SubMenuItems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EditTimeMenuItemsPtr(_result, false);
}

//
// interface RunTimeMenuItems wrapper method implementations
//

RunTimeMenuItemPtr RunTimeMenuItems::GetItem ( const _variant_t & index ) {
    struct RunTimeMenuItem * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RunTimeMenuItemPtr(_result, false);
}

IUnknownPtr RunTimeMenuItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long RunTimeMenuItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface RunTimeMenuItem wrapper method implementations
//

_bstr_t RunTimeMenuItem::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL RunTimeMenuItem::GetItemEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ItemEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT RunTimeMenuItem::InvokeItem ( const _variant_t & editArgsParam, long reserved ) {
    HRESULT _hr = raw_InvokeItem(editArgsParam, reserved);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

RunTimeMenuItemsPtr RunTimeMenuItem::GetSubMenuItems ( ) {
    struct RunTimeMenuItems * _result = 0;
    HRESULT _hr = get_SubMenuItems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RunTimeMenuItemsPtr(_result, false);
}

VARIANT_BOOL RunTimeMenuItem::GetSeparatorBefore ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeparatorBefore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL RunTimeMenuItem::GetEditsSelectedFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EditsSelectedFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface SequenceFileDiffer wrapper method implementations
//

SequenceFileDifferenceSectionPtr SequenceFileDiffer::GetDifferencesRoot ( ) {
    struct SequenceFileDifferenceSection * _result = 0;
    HRESULT _hr = get_DifferencesRoot(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileDifferenceSectionPtr(_result, false);
}

long SequenceFileDiffer::UpdateDifferences ( struct SequenceFileDifferenceSection * differSection ) {
    long _result = 0;
    HRESULT _hr = raw_UpdateDifferences(differSection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceFileDiffer::DiffSequenceFiles ( ) {
    HRESULT _hr = raw_DiffSequenceFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface SequenceFileDifferenceSection wrapper method implementations
//

_bstr_t SequenceFileDifferenceSection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long SequenceFileDifferenceSection::GetSmallIconIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SmallIconIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

PropertyObjectPtr SequenceFileDifferenceSection::GetFile1Section ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_File1Section(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

PropertyObjectPtr SequenceFileDifferenceSection::GetFile2Section ( ) {
    struct PropertyObject * _result = 0;
    HRESULT _hr = get_File2Section(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectPtr(_result, false);
}

_bstr_t SequenceFileDifferenceSection::GetFile1Location ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_File1Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t SequenceFileDifferenceSection::GetFile2Location ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_File2Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * SequenceFileDifferenceSection::GetFile1Differences ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_File1Differences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * SequenceFileDifferenceSection::GetFile2Differences ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_File2Differences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceFileDifferenceSection::GetNumberOfDifferenceGroups ( ) {
    long _result = 0;
    HRESULT _hr = get_NumberOfDifferenceGroups(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT SequenceFileDifferenceSection::GetDifferenceGroup ( long index, SAFEARRAY * * file1DifferenceGroup, SAFEARRAY * * file2DifferenceGroup ) {
    HRESULT _hr = raw_GetDifferenceGroup(index, file1DifferenceGroup, file2DifferenceGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long SequenceFileDifferenceSection::GetNumberOfDifferences ( ) {
    long _result = 0;
    HRESULT _hr = get_NumberOfDifferences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long SequenceFileDifferenceSection::GetTotalNumberOfDifferences ( ) {
    long _result = 0;
    HRESULT _hr = get_TotalNumberOfDifferences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequenceFileDifferenceSectionsPtr SequenceFileDifferenceSection::GetSubSections ( ) {
    struct SequenceFileDifferenceSections * _result = 0;
    HRESULT _hr = get_SubSections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileDifferenceSectionsPtr(_result, false);
}

//
// interface SequenceFileDifferenceSections wrapper method implementations
//

SequenceFileDifferenceSectionPtr SequenceFileDifferenceSections::GetItem ( const _variant_t & index ) {
    struct SequenceFileDifferenceSection * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileDifferenceSectionPtr(_result, false);
}

IUnknownPtr SequenceFileDifferenceSections::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long SequenceFileDifferenceSections::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface UndoItemCreator wrapper method implementations
//

VARIANT_BOOL UndoItemCreator::GetHaveEditsBeenMade ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HaveEditsBeenMade(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT UndoItemCreator::BeginEdit ( struct PropertyObject * obj ) {
    HRESULT _hr = raw_BeginEdit(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoItemCreator::EndEdit ( ) {
    HRESULT _hr = raw_EndEdit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoItemCreator::BeginBatchEdit ( SAFEARRAY * objs ) {
    HRESULT _hr = raw_BeginBatchEdit(objs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoItemCreator::EndBatchEdit ( ) {
    HRESULT _hr = raw_EndBatchEdit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IUndoItemPtr UndoItemCreator::CreateAndPostUndoItem ( long options, enum ApplicationSites locationsApplicationSite, const _variant_t & locationsUserData ) {
    struct IUndoItem * _result = 0;
    HRESULT _hr = raw_CreateAndPostUndoItem(options, locationsApplicationSite, locationsUserData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUndoItemPtr(_result, false);
}

//
// interface IUndoItem wrapper method implementations
//

PropertyObjectFilePtr IUndoItem::GetEditedFile ( ) {
    struct PropertyObjectFile * _result = 0;
    HRESULT _hr = get_EditedFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyObjectFilePtr(_result, false);
}

SAFEARRAY * IUndoItem::GetEditedObjects ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_EditedObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IUndoItem::GetUndoDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UndoDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IUndoItem::GetRedoDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RedoDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IUndoItem::GetCanUndo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUndo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IUndoItem::GetCanRedo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanRedo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum EditKinds IUndoItem::GetUndoEditKind ( ) {
    enum EditKinds _result;
    HRESULT _hr = get_UndoEditKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum EditKinds IUndoItem::GetRedoEditKind ( ) {
    enum EditKinds _result;
    HRESULT _hr = get_RedoEditKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IUndoItem::PutUndoStack ( struct UndoStack * val ) {
    HRESULT _hr = put_UndoStack(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

UndoStackPtr IUndoItem::GetUndoStack ( ) {
    struct UndoStack * _result = 0;
    HRESULT _hr = get_UndoStack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UndoStackPtr(_result, false);
}

void IUndoItem::PutRefreshEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RefreshEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IUndoItem::GetRefreshEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RefreshEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

LocationsPtr IUndoItem::GetPreEditLocations ( ) {
    struct Locations * _result = 0;
    HRESULT _hr = get_PreEditLocations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationsPtr(_result, false);
}

LocationsPtr IUndoItem::GetPostEditLocations ( ) {
    struct Locations * _result = 0;
    HRESULT _hr = get_PostEditLocations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return LocationsPtr(_result, false);
}

long IUndoItem::GetPreEditChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_PreEditChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IUndoItem::GetPostEditChangeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_PostEditChangeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IUndoItem::Undo ( ) {
    HRESULT _hr = raw_Undo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IUndoItem::Redo ( ) {
    HRESULT _hr = raw_Redo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface UndoItems wrapper method implementations
//

IUndoItemPtr UndoItems::GetItem ( long index ) {
    struct IUndoItem * _result = 0;
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUndoItemPtr(_result, false);
}

IUnknownPtr UndoItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

IUndoItemPtr UndoItems::Remove ( long index ) {
    struct IUndoItem * _result = 0;
    HRESULT _hr = raw_Remove(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUndoItemPtr(_result, false);
}

long UndoItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IUndoItemPtr UndoItems::GetTopItem ( ) {
    struct IUndoItem * _result = 0;
    HRESULT _hr = get_TopItem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUndoItemPtr(_result, false);
}

//
// interface UndoStack wrapper method implementations
//

_bstr_t UndoStack::GetUndoDescription ( _bstr_t acceleratorPrefix ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetUndoDescription(acceleratorPrefix, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t UndoStack::GetRedoDescription ( _bstr_t acceleratorPrefix ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetRedoDescription(acceleratorPrefix, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL UndoStack::GetCanUndo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUndo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL UndoStack::GetCanRedo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanRedo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT UndoStack::Undo ( ) {
    HRESULT _hr = raw_Undo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoStack::Redo ( ) {
    HRESULT _hr = raw_Redo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoStack::Push ( struct IUndoItem * Item ) {
    HRESULT _hr = raw_Push(Item);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoStack::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT UndoStack::AggregateTopUndoItems ( long numItemsToAggregate, _bstr_t aggregateItemDescription, struct Locations * aggregatePreEditLocations, struct Locations * aggregatePostEditLocations ) {
    HRESULT _hr = raw_AggregateTopUndoItems(numItemsToAggregate, aggregateItemDescription, aggregatePreEditLocations, aggregatePostEditLocations);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

UndoItemsPtr UndoStack::GetUndoItems ( ) {
    struct UndoItems * _result = 0;
    HRESULT _hr = get_UndoItems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UndoItemsPtr(_result, false);
}

UndoItemsPtr UndoStack::GetRedoItems ( ) {
    struct UndoItems * _result = 0;
    HRESULT _hr = get_RedoItems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UndoItemsPtr(_result, false);
}

} // namespace TS
