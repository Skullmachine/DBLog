// Created by Microsoft (R) C/C++ Compiler Version 10.00.40219.01 (caf11530).
//
// c:\program files (x86)\national instruments\teststand 4.2.1\components\models\teststandmodels\database\dblog\debug\tsui.tli
//
// Wrapper implementations for Win32 type library ..\..\bin\tsui.dll
// compiler-generated file created 03/17/16 at 23:42:03 - DO NOT EDIT!

#pragma once

namespace TSUI {

//
// interface IButton wrapper method implementations
//

VARIANT_BOOL IButton::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum MousePointerStyles IButton::GetMousePointer ( ) {
    enum MousePointerStyles _result;
    HRESULT _hr = get_MousePointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutMousePointer ( enum MousePointerStyles val ) {
    HRESULT _hr = put_MousePointer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * IButton::GetMouseIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MouseIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IButton::PutRefMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IButton::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IButton::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IButton::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IButton::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IButton::DoClick ( ) {
    HRESULT _hr = raw_DoClick();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IButton::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IButton::GetValue ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutValue ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Value(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ButtonSizing IButton::GetAutoSizing ( ) {
    enum ButtonSizing _result;
    HRESULT _hr = get_AutoSizing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutAutoSizing ( enum ButtonSizing val ) {
    HRESULT _hr = put_AutoSizing(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IButton::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum FontSources IButton::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IButton::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ButtonStyles IButton::GetStyle ( ) {
    enum ButtonStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutStyle ( enum ButtonStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * IButton::GetImage ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_Image(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutImage ( IPictureDisp * val ) {
    HRESULT _hr = put_Image(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IButton::PutRefImage ( IPictureDisp * val ) {
    HRESULT _hr = putref_Image(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ContentAlignmentStyles IButton::GetTextAlignment ( ) {
    enum ContentAlignmentStyles _result;
    HRESULT _hr = get_TextAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutTextAlignment ( enum ContentAlignmentStyles val ) {
    HRESULT _hr = put_TextAlignment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ContentAlignmentStyles IButton::GetImageAlignment ( ) {
    enum ContentAlignmentStyles _result;
    HRESULT _hr = get_ImageAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutImageAlignment ( enum ContentAlignmentStyles val ) {
    HRESULT _hr = put_ImageAlignment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TextImageRelations IButton::GetTextImageRelation ( ) {
    enum TextImageRelations _result;
    HRESULT _hr = get_TextImageRelation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutTextImageRelation ( enum TextImageRelations val ) {
    HRESULT _hr = put_TextImageRelation(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IButton::GetShowImage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowImage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutShowImage ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowImage(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IButton::GetShowText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutShowText ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IButton::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IButton::GetForeColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ForeColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutForeColor ( OLE_COLOR val ) {
    HRESULT _hr = put_ForeColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ButtonActionStyles IButton::GetActionStyle ( ) {
    enum ButtonActionStyles _result;
    HRESULT _hr = get_ActionStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutActionStyle ( enum ButtonActionStyles val ) {
    HRESULT _hr = put_ActionStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IButton::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IButton::PutToolTipText ( _bstr_t val ) {
    HRESULT _hr = put_ToolTipText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IButton::GetUseMnemonic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMnemonic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutUseMnemonic ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMnemonic(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IButton::GetUseMaskColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMaskColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutUseMaskColor ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMaskColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IButton::GetMaskColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_MaskColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IButton::PutMaskColor ( OLE_COLOR val ) {
    HRESULT _hr = put_MaskColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _ButtonEvents wrapper method implementations
//

HRESULT _ButtonEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ButtonEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _ButtonEvents::KeyPress ( short * keyAscii ) {
    return _com_dispatch_method(this, DISPID_KEYPRESS, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002", keyAscii);
}

HRESULT _ButtonEvents::KeyUp ( short keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", keyCode, shift);
}

HRESULT _ButtonEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ButtonEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ButtonEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ButtonEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface Borders wrapper method implementations
//

long Borders::GetVisibleBorders ( ) {
    long _result = 0;
    HRESULT _hr = get_VisibleBorders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutVisibleBorders ( long val ) {
    HRESULT _hr = put_VisibleBorders(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Borders::GetBorderWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_BorderWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutBorderWidth ( long val ) {
    HRESULT _hr = put_BorderWidth(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum EdgeStyles Borders::GetBorderEdgeStyle ( ) {
    enum EdgeStyles _result;
    HRESULT _hr = get_BorderEdgeStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutBorderEdgeStyle ( enum EdgeStyles val ) {
    HRESULT _hr = put_BorderEdgeStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum EdgeStyles Borders::GetFrameEdgeStyle ( ) {
    enum EdgeStyles _result;
    HRESULT _hr = get_FrameEdgeStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutFrameEdgeStyle ( enum EdgeStyles val ) {
    HRESULT _hr = put_FrameEdgeStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Borders::GetFrameVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FrameVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutFrameVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_FrameVisible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Borders::GetFrameInsideBorders ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FrameInsideBorders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutFrameInsideBorders ( VARIANT_BOOL val ) {
    HRESULT _hr = put_FrameInsideBorders(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Borders::GetBorderDraggedEventEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BorderDraggedEventEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Borders::PutBorderDraggedEventEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BorderDraggedEventEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT Borders::GetFrameThickness ( long * verticalThickness, long * horizontalThickness ) {
    HRESULT _hr = raw_GetFrameThickness(verticalThickness, horizontalThickness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ExpressionEditButton wrapper method implementations
//

VARIANT_BOOL ExpressionEditButton::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ExpressionEditButton::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPictureDisp * ExpressionEditButton::GetIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_Icon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_Icon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ExpressionEditButton::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ExpressionEditButton::GetKind ( ) {
    long _result = 0;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutKind ( long val ) {
    HRESULT _hr = put_Kind(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExpressionEditButton::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExpressionEditButton::PutToolTipText ( _bstr_t val ) {
    HRESULT _hr = put_ToolTipText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExpressionEditButton::GetContextMenuItemCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ContextMenuItemCaption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExpressionEditButton::PutContextMenuItemCaption ( _bstr_t val ) {
    HRESULT _hr = put_ContextMenuItemCaption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ShortcutKeys ExpressionEditButton::GetShortcutKey ( ) {
    enum ShortcutKeys _result;
    HRESULT _hr = get_ShortcutKey(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutShortcutKey ( enum ShortcutKeys val ) {
    HRESULT _hr = put_ShortcutKey(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ExpressionEditButton::GetShortcutModifier ( ) {
    long _result = 0;
    HRESULT _hr = get_ShortcutModifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutShortcutModifier ( long val ) {
    HRESULT _hr = put_ShortcutModifier(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ExpressionEditButton::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Visible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ExpressionEditButtonStyles ExpressionEditButton::GetStyle ( ) {
    enum ExpressionEditButtonStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditButton::PutStyle ( enum ExpressionEditButtonStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT ExpressionEditButton::DoClick ( ) {
    HRESULT _hr = raw_DoClick();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ExpressionEditButtons wrapper method implementations
//

IUnknownPtr ExpressionEditButtons::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

ExpressionEditButtonPtr ExpressionEditButtons::GetItem ( long indexOrKind, enum SpecifyExpressionEditButton specify ) {
    struct ExpressionEditButton * _result = 0;
    HRESULT _hr = raw_GetItem(indexOrKind, specify, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditButtonPtr(_result, false);
}

long ExpressionEditButtons::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT ExpressionEditButtons::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ExpressionEditButtonPtr ExpressionEditButtons::Insert ( long itemIndexParam, long Kind ) {
    struct ExpressionEditButton * _result = 0;
    HRESULT _hr = raw_Insert(itemIndexParam, Kind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditButtonPtr(_result, false);
}

HRESULT ExpressionEditButtons::Remove ( long indexOrKind, enum SpecifyExpressionEditButton specify ) {
    HRESULT _hr = raw_Remove(indexOrKind, specify);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ExpressionEditComboBoxItem wrapper method implementations
//

IPictureDisp * ExpressionEditComboBoxItem::GetIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_Icon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ExpressionEditComboBoxItem::PutIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_Icon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExpressionEditComboBoxItem::GetValue ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExpressionEditComboBoxItem::PutValue ( _bstr_t val ) {
    HRESULT _hr = put_Value(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ExpressionEditComboBoxItem::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ExpressionEditComboBoxItem::PutDisplayName ( _bstr_t val ) {
    HRESULT _hr = put_DisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ExpressionEditComboBoxItem::PutRefIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_Icon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ExpressionEditComboBoxItems wrapper method implementations
//

ExpressionEditComboBoxItemPtr ExpressionEditComboBoxItems::GetItem ( long itemIndexParam ) {
    struct ExpressionEditComboBoxItem * _result = 0;
    HRESULT _hr = get_Item(itemIndexParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditComboBoxItemPtr(_result, false);
}

IUnknownPtr ExpressionEditComboBoxItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long ExpressionEditComboBoxItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT ExpressionEditComboBoxItems::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ExpressionEditComboBoxItemPtr ExpressionEditComboBoxItems::Insert ( long itemIndexParam, _bstr_t val, _bstr_t DisplayName, IPictureDisp * Icon ) {
    struct ExpressionEditComboBoxItem * _result = 0;
    HRESULT _hr = raw_Insert(itemIndexParam, val, DisplayName, Icon, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditComboBoxItemPtr(_result, false);
}

HRESULT ExpressionEditComboBoxItems::Remove ( long itemIndexParam ) {
    HRESULT _hr = raw_Remove(itemIndexParam);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IExpressionEdit wrapper method implementations
//

OLE_COLOR IExpressionEdit::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

BordersPtr IExpressionEdit::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

VARIANT_BOOL IExpressionEdit::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetHideSelection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HideSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutHideSelection ( VARIANT_BOOL val ) {
    HRESULT _hr = put_HideSelection(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IExpressionEdit::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IExpressionEdit::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IExpressionEdit::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutReadOnly ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ReadOnly(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetMaxLength ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutMaxLength ( long val ) {
    HRESULT _hr = put_MaxLength(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * IExpressionEdit::GetMouseIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MouseIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IExpressionEdit::PutRefMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum MousePointerStyles IExpressionEdit::GetMousePointer ( ) {
    enum MousePointerStyles _result;
    HRESULT _hr = get_MousePointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutMousePointer ( enum MousePointerStyles val ) {
    HRESULT _hr = put_MousePointer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetMultiline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Multiline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutMultiline ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Multiline(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ScrollBars IExpressionEdit::GetScrollBars ( ) {
    enum ScrollBars _result;
    HRESULT _hr = get_ScrollBars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutScrollBars ( enum ScrollBars val ) {
    HRESULT _hr = put_ScrollBars(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetSelLength ( ) {
    long _result = 0;
    HRESULT _hr = get_SelLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutSelLength ( long val ) {
    HRESULT _hr = put_SelLength(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetSelStart ( ) {
    long _result = 0;
    HRESULT _hr = get_SelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutSelStart ( long val ) {
    HRESULT _hr = put_SelStart(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IExpressionEdit::GetSelText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IExpressionEdit::PutSelText ( _bstr_t val ) {
    HRESULT _hr = put_SelText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IExpressionEdit::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IExpressionEdit::PutText ( _bstr_t val ) {
    HRESULT _hr = put_Text(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetTextLength ( ) {
    long _result = 0;
    HRESULT _hr = get_TextLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum BooleanOrPreference IExpressionEdit::GetWantReturn ( ) {
    enum BooleanOrPreference _result;
    HRESULT _hr = get_WantReturn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutWantReturn ( enum BooleanOrPreference val ) {
    HRESULT _hr = put_WantReturn(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum BooleanOrPreference IExpressionEdit::GetWordWrap ( ) {
    enum BooleanOrPreference _result;
    HRESULT _hr = get_WordWrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutWordWrap ( enum BooleanOrPreference val ) {
    HRESULT _hr = put_WordWrap(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IExpressionEdit::SelectAll ( ) {
    HRESULT _hr = raw_SelectAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::IEnginePtr IExpressionEdit::GetEngine ( ) {
    struct TS::IEngine * _result = 0;
    HRESULT _hr = get_Engine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::IEnginePtr(_result, false);
}

void IExpressionEdit::PutRefEngine ( struct TS::IEngine * val ) {
    HRESULT _hr = putref_Engine(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::PropertyObjectPtr IExpressionEdit::GetContext ( ) {
    struct TS::PropertyObject * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::PropertyObjectPtr(_result, false);
}

void IExpressionEdit::PutRefContext ( struct TS::PropertyObject * val ) {
    HRESULT _hr = putref_Context(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetAutoLocalize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoLocalize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutAutoLocalize ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoLocalize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TextTypes IExpressionEdit::GetTextType ( ) {
    enum TextTypes _result;
    HRESULT _hr = get_TextType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutTextType ( enum TextTypes val ) {
    HRESULT _hr = put_TextType(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetSyntaxHighlightingEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SyntaxHighlightingEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutSyntaxHighlightingEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_SyntaxHighlightingEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::PropertyObjectPtr IExpressionEdit::Evaluate ( long evaluationOptions ) {
    struct TS::PropertyObject * _result = 0;
    HRESULT _hr = raw_Evaluate(evaluationOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::PropertyObjectPtr(_result, false);
}

long IExpressionEdit::GetFunctionTipHwnd ( ) {
    long _result = 0;
    HRESULT _hr = get_FunctionTipHwnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IExpressionEdit::GetAutoCompletionHwnd ( ) {
    long _result = 0;
    HRESULT _hr = get_AutoCompletionHwnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IExpressionEdit::GetAllowEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutAllowEmpty ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AllowEmpty(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ErrorCheck IExpressionEdit::GetErrorCheck ( ) {
    enum ErrorCheck _result;
    HRESULT _hr = get_ErrorCheck(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutErrorCheck ( enum ErrorCheck val ) {
    HRESULT _hr = put_ErrorCheck(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetRequiredTypes ( ) {
    long _result = 0;
    HRESULT _hr = get_RequiredTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutRequiredTypes ( long val ) {
    HRESULT _hr = put_RequiredTypes(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

StringsPtr IExpressionEdit::GetRequiredNamedTypes ( ) {
    struct Strings * _result = 0;
    HRESULT _hr = get_RequiredNamedTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StringsPtr(_result, false);
}

StringsPtr IExpressionEdit::GetRequiredNamedTypeArrays ( ) {
    struct Strings * _result = 0;
    HRESULT _hr = get_RequiredNamedTypeArrays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StringsPtr(_result, false);
}

enum TS::TSError IExpressionEdit::CheckExpression ( BSTR * errorDescription, long * errorStartPosition, long * errorEndPosition ) {
    enum TS::TSError _result;
    HRESULT _hr = raw_CheckExpression(errorDescription, errorStartPosition, errorEndPosition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IExpressionEdit::DisplayError ( long options ) {
    HRESULT _hr = raw_DisplayError(options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IExpressionEdit::GetBrowseExprDialogTitle ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BrowseExprDialogTitle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IExpressionEdit::PutBrowseExprDialogTitle ( _bstr_t val ) {
    HRESULT _hr = put_BrowseExprDialogTitle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetBrowseExprDialogOptions ( ) {
    long _result = 0;
    HRESULT _hr = get_BrowseExprDialogOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutBrowseExprDialogOptions ( long val ) {
    HRESULT _hr = put_BrowseExprDialogOptions(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::DisplayBrowseExprDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DisplayBrowseExprDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum FontSources IExpressionEdit::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IExpressionEdit::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

ExpressionEditButtonsPtr IExpressionEdit::GetButtons ( ) {
    struct ExpressionEditButtons * _result = 0;
    HRESULT _hr = get_Buttons(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditButtonsPtr(_result, false);
}

enum ExpressionEditStyles IExpressionEdit::GetStyle ( ) {
    enum ExpressionEditStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutStyle ( enum ExpressionEditStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ExpressionEditComboBoxItemsPtr IExpressionEdit::GetComboBoxItems ( ) {
    struct ExpressionEditComboBoxItems * _result = 0;
    HRESULT _hr = get_ComboBoxItems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExpressionEditComboBoxItemsPtr(_result, false);
}

VARIANT_BOOL IExpressionEdit::GetShowDisplayNameWhenInactive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowDisplayNameWhenInactive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutShowDisplayNameWhenInactive ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowDisplayNameWhenInactive(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IExpressionEdit::GetDropDownListHwnd ( ) {
    long _result = 0;
    HRESULT _hr = get_DropDownListHwnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IExpressionEdit::GetDisplayText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IExpressionEdit::PutDisplayText ( _bstr_t val ) {
    HRESULT _hr = put_DisplayText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExpressionEdit::GetDisplayFormattedValue ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DisplayFormattedValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutDisplayFormattedValue ( VARIANT_BOOL val ) {
    HRESULT _hr = put_DisplayFormattedValue(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IExpressionEdit::GetNumericFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_NumericFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IExpressionEdit::PutNumericFormat ( _bstr_t val ) {
    HRESULT _hr = put_NumericFormat(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IExpressionEdit::GetAdditionalEvaluationConstants ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAdditionalEvaluationConstants(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IExpressionEdit::SetAdditionalEvaluationConstants ( SAFEARRAY * val ) {
    HRESULT _hr = raw_SetAdditionalEvaluationConstants(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum BooleanOrPreference IExpressionEdit::GetAutomaticallyPrefixVariables ( ) {
    enum BooleanOrPreference _result;
    HRESULT _hr = get_AutomaticallyPrefixVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExpressionEdit::PutAutomaticallyPrefixVariables ( enum BooleanOrPreference val ) {
    HRESULT _hr = put_AutomaticallyPrefixVariables(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _ExpressionEditEvents wrapper method implementations
//

HRESULT _ExpressionEditEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExpressionEditEvents::DblClick ( ) {
    return _com_dispatch_method(this, DISPID_DBLCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExpressionEditEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _ExpressionEditEvents::KeyPress ( short * keyAscii ) {
    return _com_dispatch_method(this, DISPID_KEYPRESS, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002", keyAscii);
}

HRESULT _ExpressionEditEvents::KeyUp ( short keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", keyCode, shift);
}

HRESULT _ExpressionEditEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ExpressionEditEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ExpressionEditEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ExpressionEditEvents::Change ( ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExpressionEditEvents::SelChange ( ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExpressionEditEvents::BrowseExprDialogClosed ( VARIANT_BOOL userHitOK, VARIANT_BOOL contextModified ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000b\x000b", userHitOK, contextModified);
}

HRESULT _ExpressionEditEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _ExpressionEditEvents::ButtonClick ( struct ExpressionEditButton * btn ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", btn);
}

HRESULT _ExpressionEditEvents::DropDown ( ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExpressionEditEvents::InsertComboBoxItem ( struct ExpressionEditComboBoxItem * Item, long * insertStart, long * insertEnd ) {
    return _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x4003\x4003", Item, insertStart, insertEnd);
}

HRESULT _ExpressionEditEvents::CreateContextMenu ( long menuHandle, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003", menuHandle, x, y);
}

HRESULT _ExpressionEditEvents::ContextMenuItemClick ( long menuItemId ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", menuItemId);
}

HRESULT _ExpressionEditEvents::ContextChanged ( enum ContextChangedReasons reason ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", reason);
}

HRESULT _ExpressionEditEvents::BrowseExprDialogOpened ( BSTR * dlgTitle, long * dlgOptions, long * selectionStart, long * selectionEnd, BSTR * initialVariableName, VARIANT_BOOL * cancel ) {
    return _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4008\x4003\x4003\x4003\x4008\x400b", dlgTitle, dlgOptions, selectionStart, selectionEnd, initialVariableName, cancel);
}

HRESULT _ExpressionEditEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

HRESULT _ExpressionEditEvents::CheckExpression ( enum TS::TSError * errorCode, BSTR * errorDescription, long * errorStartPosition, long * errorEndPosition ) {
    return _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4003\x4008\x4003\x4003", errorCode, errorDescription, errorStartPosition, errorEndPosition);
}

//
// interface ListBarPageItem wrapper method implementations
//

_bstr_t ListBarPageItem::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ListBarPageItem::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ListBarPageItem::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ListBarPageItem::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ListBarPageItem::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t ListBarPageItem::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ListBarPageItem::PutToolTipText ( _bstr_t val ) {
    HRESULT _hr = put_ToolTipText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ListBarPageItems wrapper method implementations
//

IUnknownPtr ListBarPageItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

ListBarPageItemPtr ListBarPageItems::GetItem ( const _variant_t & itemIdx ) {
    struct ListBarPageItem * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPageItemPtr(_result, false);
}

long ListBarPageItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ListBarPageItemPtr ListBarPageItems::Insert ( _bstr_t itemCaption, _bstr_t IconName, long insertBefore ) {
    struct ListBarPageItem * _result = 0;
    HRESULT _hr = raw_Insert(itemCaption, IconName, insertBefore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPageItemPtr(_result, false);
}

HRESULT ListBarPageItems::Remove ( long itemIdx ) {
    HRESULT _hr = raw_Remove(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ListBarPageItems::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ListBarPage wrapper method implementations
//

void ListBarPage::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ListBarPage::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long ListBarPage::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ListBarPage::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ListBarPage::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

ListBarPageItemsPtr ListBarPage::GetItems ( ) {
    struct ListBarPageItems * _result = 0;
    HRESULT _hr = get_Items(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPageItemsPtr(_result, false);
}

void ListBarPage::PutCursor ( long val ) {
    HRESULT _hr = put_Cursor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ListBarPage::GetCursor ( ) {
    long _result = 0;
    HRESULT _hr = get_Cursor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL ListBarPage::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ListBarPage::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ListBarPages wrapper method implementations
//

IUnknownPtr ListBarPages::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

ListBarPagePtr ListBarPages::GetItem ( const _variant_t & itemIdx ) {
    struct ListBarPage * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPagePtr(_result, false);
}

long ListBarPages::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ListBarPagePtr ListBarPages::Insert ( _bstr_t pageName, long insertBefore ) {
    struct ListBarPage * _result = 0;
    HRESULT _hr = raw_Insert(pageName, insertBefore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPagePtr(_result, false);
}

HRESULT ListBarPages::Remove ( long itemIdx ) {
    HRESULT _hr = raw_Remove(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ListBarPages::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IListBar wrapper method implementations
//

long IListBar::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum ListBarButtonStyles IListBar::GetButtonStyle ( ) {
    enum ListBarButtonStyles _result;
    HRESULT _hr = get_ButtonStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutButtonStyle ( enum ListBarButtonStyles val ) {
    HRESULT _hr = put_ButtonStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBar::PutButtonFont ( IFontDisp * val ) {
    HRESULT _hr = put_ButtonFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBar::PutRefButtonFont ( IFontDisp * val ) {
    HRESULT _hr = putref_ButtonFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IListBar::GetButtonFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_ButtonFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IListBar::GetPageStyle ( ) {
    long _result = 0;
    HRESULT _hr = get_PageStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutPageStyle ( long val ) {
    HRESULT _hr = put_PageStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBar::PutRefPageFont ( IFontDisp * val ) {
    HRESULT _hr = putref_PageFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBar::PutPageFont ( IFontDisp * val ) {
    HRESULT _hr = put_PageFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IListBar::GetPageFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_PageFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

ListBarPagesPtr IListBar::GetPages ( ) {
    struct ListBarPages * _result = 0;
    HRESULT _hr = get_Pages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBarPagesPtr(_result, false);
}

long IListBar::GetCurrentPage ( ) {
    long _result = 0;
    HRESULT _hr = get_CurrentPage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutCurrentPage ( long val ) {
    HRESULT _hr = put_CurrentPage(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IListBar::HitTest ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_HitTest(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IListBar::GetShowItemCount ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowItemCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutShowItemCount ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowItemCount(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IListBar::GetButtonTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ButtonTextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutButtonTextColor ( OLE_COLOR val ) {
    HRESULT _hr = put_ButtonTextColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IListBar::GetPageTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_PageTextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutPageTextColor ( OLE_COLOR val ) {
    HRESULT _hr = put_PageTextColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IListBar::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IListBar::GetShowItemTipStrips ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowItemTipStrips(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutShowItemTipStrips ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowItemTipStrips(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IListBar::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IListBar::GetIconSize ( ) {
    long _result = 0;
    HRESULT _hr = get_IconSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutIconSize ( long val ) {
    HRESULT _hr = put_IconSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IListBar::GetShowScrollBar ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowScrollBar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutShowScrollBar ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowScrollBar(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources IListBar::GetButtonFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_ButtonFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutButtonFontSource ( enum FontSources val ) {
    HRESULT _hr = put_ButtonFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources IListBar::GetPageFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_PageFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutPageFontSource ( enum FontSources val ) {
    HRESULT _hr = put_PageFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IListBar::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBar::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

BordersPtr IListBar::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

//
// dispinterface _ListBarEvents wrapper method implementations
//

HRESULT _ListBarEvents::CursorMoved ( long itemIdx ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", itemIdx);
}

HRESULT _ListBarEvents::CurPageChanged ( long CurrentPage ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", CurrentPage);
}

HRESULT _ListBarEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _ListBarEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBarEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBarEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBarEvents::DblClick ( ) {
    return _com_dispatch_method(this, DISPID_DBLCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ListBarEvents::CreateContextMenu ( long menuHandle, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003", menuHandle, x, y);
}

HRESULT _ListBarEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _ListBarEvents::ConnectionActivity ( enum ConnectionActivityTypes activity, long pageIndex ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003", activity, pageIndex);
}

//
// interface StatusBarPane wrapper method implementations
//

void StatusBarPane::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StatusBarPane::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

double StatusBarPane::GetProcessPercent ( ) {
    double _result = 0;
    HRESULT _hr = get_ProcessPercent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutProcessPercent ( double val ) {
    HRESULT _hr = put_ProcessPercent(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StatusBarPane::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StatusBarPane::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StatusBarPane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StatusBarPane::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StatusBarPane::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutWidth ( long val ) {
    HRESULT _hr = put_Width(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum StatusBarPaneStyles StatusBarPane::GetStyle ( ) {
    enum StatusBarPaneStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutStyle ( enum StatusBarPaneStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long StatusBarPane::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AlignmentStyles StatusBarPane::GetTextAlignment ( ) {
    enum AlignmentStyles _result;
    HRESULT _hr = get_TextAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutTextAlignment ( enum AlignmentStyles val ) {
    HRESULT _hr = put_TextAlignment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StatusBarPane::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Visible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL StatusBarPane::GetUseAvailableSpace ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAvailableSpace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void StatusBarPane::PutUseAvailableSpace ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseAvailableSpace(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t StatusBarPane::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void StatusBarPane::PutToolTipText ( _bstr_t val ) {
    HRESULT _hr = put_ToolTipText(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface StatusBarPanes wrapper method implementations
//

StatusBarPanePtr StatusBarPanes::GetItem ( const _variant_t & paneIndex ) {
    struct StatusBarPane * _result = 0;
    HRESULT _hr = get_Item(paneIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StatusBarPanePtr(_result, false);
}

IUnknownPtr StatusBarPanes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long StatusBarPanes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

StatusBarPanePtr StatusBarPanes::Insert ( _bstr_t paneName, long insertBefore ) {
    struct StatusBarPane * _result = 0;
    HRESULT _hr = raw_Insert(paneName, insertBefore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StatusBarPanePtr(_result, false);
}

HRESULT StatusBarPanes::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT StatusBarPanes::Remove ( const _variant_t & paneIndex ) {
    HRESULT _hr = raw_Remove(paneIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IStatusBar wrapper method implementations
//

StatusBarPanesPtr IStatusBar::GetPanes ( ) {
    struct StatusBarPanes * _result = 0;
    HRESULT _hr = get_Panes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StatusBarPanesPtr(_result, false);
}

void IStatusBar::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IStatusBar::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IStatusBar::GetAutoSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutAutoSize ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IStatusBar::GetShowTopDivider ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowTopDivider(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutShowTopDivider ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowTopDivider(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IStatusBar::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IStatusBar::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long IStatusBar::HitTest ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_HitTest(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IStatusBar::ShowPanes ( _bstr_t panesList ) {
    HRESULT _hr = raw_ShowPanes(panesList);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

void IStatusBar::PutShowResizingGrip ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowResizingGrip(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IStatusBar::GetShowResizingGrip ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowResizingGrip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IStatusBar::GetIconSize ( ) {
    long _result = 0;
    HRESULT _hr = get_IconSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutIconSize ( long val ) {
    HRESULT _hr = put_IconSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources IStatusBar::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IStatusBar::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IStatusBar::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _StatusBarEvents wrapper method implementations
//

HRESULT _StatusBarEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _StatusBarEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _StatusBarEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _StatusBarEvents::DblClick ( ) {
    return _com_dispatch_method(this, DISPID_DBLCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _StatusBarEvents::Resized ( short newWidth, short newHeight ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", newWidth, newHeight);
}

HRESULT _StatusBarEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface IComboBox wrapper method implementations
//

VARIANT_BOOL IComboBox::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum MousePointerStyles IComboBox::GetMousePointer ( ) {
    enum MousePointerStyles _result;
    HRESULT _hr = get_MousePointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutMousePointer ( enum MousePointerStyles val ) {
    HRESULT _hr = put_MousePointer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * IComboBox::GetMouseIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MouseIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IComboBox::PutRefMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IComboBox::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IComboBox::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IComboBox::GetItemIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_ItemIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutItemIndex ( long val ) {
    HRESULT _hr = put_ItemIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IComboBox::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutReadOnly ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ReadOnly(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IComboBox::GetHeightWithDropDown ( ) {
    long _result = 0;
    HRESULT _hr = get_HeightWithDropDown(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutHeightWithDropDown ( long val ) {
    HRESULT _hr = put_HeightWithDropDown(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ComboBoxStyles IComboBox::GetStyle ( ) {
    enum ComboBoxStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutStyle ( enum ComboBoxStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IComboBox::GetIconSize ( ) {
    long _result = 0;
    HRESULT _hr = get_IconSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutIconSize ( long val ) {
    HRESULT _hr = put_IconSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IComboBox::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum FontSources IComboBox::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IComboBox::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IComboBox::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IComboBox::GetItemText ( long itemIdx ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetItemText(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IComboBox::GetShowImages ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowImages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutShowImages ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowImages(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IComboBox::GetToolTipVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ToolTipVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IComboBox::PutToolTipVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ToolTipVisible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _ComboBoxEvents wrapper method implementations
//

HRESULT _ComboBoxEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ComboBoxEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _ComboBoxEvents::KeyPress ( short * keyAscii ) {
    return _com_dispatch_method(this, DISPID_KEYPRESS, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002", keyAscii);
}

HRESULT _ComboBoxEvents::KeyUp ( short keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", keyCode, shift);
}

HRESULT _ComboBoxEvents::Change ( ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ComboBoxEvents::DropDown ( ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ComboBoxEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface ListBoxColumn wrapper method implementations
//

long ListBoxColumn::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long ListBoxColumn::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ListBoxColumn::PutWidth ( long val ) {
    HRESULT _hr = put_Width(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AutoSizingOptions ListBoxColumn::GetAutoSizing ( ) {
    enum AutoSizingOptions _result;
    HRESULT _hr = get_AutoSizing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ListBoxColumn::PutAutoSizing ( enum AutoSizingOptions val ) {
    HRESULT _hr = put_AutoSizing(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ListBoxColumn::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ListBoxColumns wrapper method implementations
//

ListBoxColumnPtr ListBoxColumns::GetItem ( long itemIdx ) {
    struct ListBoxColumn * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBoxColumnPtr(_result, false);
}

IUnknownPtr ListBoxColumns::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long ListBoxColumns::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IListBox wrapper method implementations
//

VARIANT_BOOL IListBox::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum MousePointerStyles IListBox::GetMousePointer ( ) {
    enum MousePointerStyles _result;
    HRESULT _hr = get_MousePointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutMousePointer ( enum MousePointerStyles val ) {
    HRESULT _hr = put_MousePointer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * IListBox::GetMouseIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MouseIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBox::PutRefMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IListBox::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IListBox::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IListBox::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IListBox::GetItemIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_ItemIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutItemIndex ( long val ) {
    HRESULT _hr = put_ItemIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IListBox::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IListBox::GetColumns ( ) {
    long _result = 0;
    HRESULT _hr = get_Columns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutColumns ( long val ) {
    HRESULT _hr = put_Columns(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IListBox::GetForeColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ForeColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutForeColor ( OLE_COLOR val ) {
    HRESULT _hr = put_ForeColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IListBox::HitTest ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_HitTest(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IListBox::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum FontSources IListBox::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IListBox::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IListBox::GetItemText ( long itemIdx ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetItemText(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IListBox::GetToolTipVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ToolTipVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutToolTipVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ToolTipVisible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

BordersPtr IListBox::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

long IListBox::GetEditingFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_EditingFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutEditingFlags ( long val ) {
    HRESULT _hr = put_EditingFlags(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IListBox::GetCanEditLabel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanEditLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IListBox::EditLabel ( ) {
    HRESULT _hr = raw_EditLabel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IListBox::GetShowHeaders ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowHeaders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutShowHeaders ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowHeaders(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ListBoxColumnsPtr IListBox::GetColumnSet ( ) {
    struct ListBoxColumns * _result = 0;
    HRESULT _hr = get_ColumnSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ListBoxColumnsPtr(_result, false);
}

VARIANT_BOOL IListBox::GetAutoSizeColumns ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSizeColumns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IListBox::PutAutoSizeColumns ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoSizeColumns(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _ListBoxEvents wrapper method implementations
//

HRESULT _ListBoxEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ListBoxEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _ListBoxEvents::KeyPress ( short * keyAscii ) {
    return _com_dispatch_method(this, DISPID_KEYPRESS, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002", keyAscii);
}

HRESULT _ListBoxEvents::KeyUp ( short keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", keyCode, shift);
}

HRESULT _ListBoxEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBoxEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBoxEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _ListBoxEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _ListBoxEvents::CreateContextMenu ( long menuHandle, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003", menuHandle, x, y);
}

HRESULT _ListBoxEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

HRESULT _ListBoxEvents::DblClick ( ) {
    return _com_dispatch_method(this, DISPID_DBLCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ListBoxEvents::ColumnsResized ( ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//
// interface ILabel wrapper method implementations
//

VARIANT_BOOL ILabel::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum MousePointerStyles ILabel::GetMousePointer ( ) {
    enum MousePointerStyles _result;
    HRESULT _hr = get_MousePointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutMousePointer ( enum MousePointerStyles val ) {
    HRESULT _hr = put_MousePointer(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IPictureDisp * ILabel::GetMouseIcon ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_MouseIcon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = put_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ILabel::PutRefMouseIcon ( IPictureDisp * val ) {
    HRESULT _hr = putref_MouseIcon(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * ILabel::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ILabel::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ILabel::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ILabel::GetForeColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ForeColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutForeColor ( OLE_COLOR val ) {
    HRESULT _hr = put_ForeColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ILabel::GetAutoSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutAutoSize ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ILabel::GetWordWrap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WordWrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutWordWrap ( VARIANT_BOOL val ) {
    HRESULT _hr = put_WordWrap(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ILabel::GetUseMnemonic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMnemonic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutUseMnemonic ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMnemonic(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ILabel::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ILabel::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum BorderStyles ILabel::GetBorderStyle ( ) {
    enum BorderStyles _result;
    HRESULT _hr = get_BorderStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutBorderStyle ( enum BorderStyles val ) {
    HRESULT _hr = put_BorderStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AlignmentStyles ILabel::GetAlignment ( ) {
    enum AlignmentStyles _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutAlignment ( enum AlignmentStyles val ) {
    HRESULT _hr = put_Alignment(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT ILabel::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum FontSources ILabel::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ILabel::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ILabel::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _LabelEvents wrapper method implementations
//

HRESULT _LabelEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _LabelEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _LabelEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _LabelEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _LabelEvents::Change ( ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _LabelEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface IReportView wrapper method implementations
//

HRESULT IReportView::PrintReport ( VARIANT_BOOL showPrintDialog ) {
    HRESULT _hr = raw_PrintReport(showPrintDialog);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IReportView::UpdateFromExecution ( struct TS::Execution * exec ) {
    HRESULT _hr = raw_UpdateFromExecution(exec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IDispatchPtr IReportView::GetHTMLCtrl ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_GetHTMLCtrl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

long IReportView::GetRichEditCtrl ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetRichEditCtrl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IReportView::GetToolBarVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ToolBarVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutToolBarVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ToolBarVisible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IReportView::GetLargeIcons ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LargeIcons(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutLargeIcons ( VARIANT_BOOL val ) {
    HRESULT _hr = put_LargeIcons(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ToolBarTextStyles IReportView::GetToolBarTextStyle ( ) {
    enum ToolBarTextStyles _result;
    HRESULT _hr = get_ToolBarTextStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutToolBarTextStyle ( enum ToolBarTextStyles val ) {
    HRESULT _hr = put_ToolBarTextStyle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IReportView::GetButtonsVisible ( ) {
    long _result = 0;
    HRESULT _hr = get_ButtonsVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutButtonsVisible ( long val ) {
    HRESULT _hr = put_ButtonsVisible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * IReportView::GetTextReportFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_TextReportFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutTextReportFont ( IFontDisp * val ) {
    HRESULT _hr = put_TextReportFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void IReportView::PutRefTextReportFont ( IFontDisp * val ) {
    HRESULT _hr = putref_TextReportFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources IReportView::GetTextReportFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_TextReportFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutTextReportFontSource ( enum FontSources val ) {
    HRESULT _hr = put_TextReportFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IReportView::GetTextReportColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextReportColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutTextReportColor ( OLE_COLOR val ) {
    HRESULT _hr = put_TextReportColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR IReportView::GetTextReportBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextReportBackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutTextReportBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_TextReportBackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IReportView::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IReportView::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

BordersPtr IReportView::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

//
// dispinterface _ReportViewEvents wrapper method implementations
//

HRESULT _ReportViewEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _ReportViewEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface SeqViewColumn wrapper method implementations
//

_bstr_t SeqViewColumn::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SeqViewColumn::PutName ( _bstr_t val ) {
    HRESULT _hr = put_Name(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SeqViewColumn::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SeqViewColumn::PutWidth ( long val ) {
    HRESULT _hr = put_Width(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SeqViewColumn::GetExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Expression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SeqViewColumn::PutExpression ( _bstr_t val ) {
    HRESULT _hr = put_Expression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL SeqViewColumn::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SeqViewColumn::PutVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Visible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum SeqViewColumnTypes SeqViewColumn::GetType ( ) {
    enum SeqViewColumnTypes _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SeqViewColumn::PutType ( enum SeqViewColumnTypes val ) {
    HRESULT _hr = put_Type(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SeqViewColumn::GetTextColorExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TextColorExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SeqViewColumn::PutTextColorExpression ( _bstr_t val ) {
    HRESULT _hr = put_TextColorExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t SeqViewColumn::GetBackColorExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BackColorExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SeqViewColumn::PutBackColorExpression ( _bstr_t val ) {
    HRESULT _hr = put_BackColorExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long SeqViewColumn::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t SeqViewColumn::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void SeqViewColumn::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AutoSizingOptions SeqViewColumn::GetAutoSizing ( ) {
    enum AutoSizingOptions _result;
    HRESULT _hr = get_AutoSizing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void SeqViewColumn::PutAutoSizing ( enum AutoSizingOptions val ) {
    HRESULT _hr = put_AutoSizing(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface SeqViewColumns wrapper method implementations
//

SeqViewColumnPtr SeqViewColumns::GetItem ( const _variant_t & itemIdx ) {
    struct SeqViewColumn * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SeqViewColumnPtr(_result, false);
}

IUnknownPtr SeqViewColumns::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long SeqViewColumns::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SeqViewColumnPtr SeqViewColumns::Insert ( _bstr_t itemName, enum SeqViewColumnTypes columnType, long columnWidth, long insertBefore ) {
    struct SeqViewColumn * _result = 0;
    HRESULT _hr = raw_Insert(itemName, columnType, columnWidth, insertBefore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SeqViewColumnPtr(_result, false);
}

HRESULT SeqViewColumns::Remove ( long itemIdx ) {
    HRESULT _hr = raw_Remove(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SeqViewColumns::MoveLeft ( long itemIdx ) {
    HRESULT _hr = raw_MoveLeft(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SeqViewColumns::MoveRight ( long itemIdx ) {
    HRESULT _hr = raw_MoveRight(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT SeqViewColumns::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISequenceView wrapper method implementations
//

long ISequenceView::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

OLE_COLOR ISequenceView::GetTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutTextColor ( OLE_COLOR val ) {
    HRESULT _hr = put_TextColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetShowComments ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowComments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutShowComments ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowComments(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ISequenceView::GetCommentsColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_CommentsColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutCommentsColor ( OLE_COLOR val ) {
    HRESULT _hr = put_CommentsColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ISequenceView::PutLinesColor ( OLE_COLOR val ) {
    HRESULT _hr = put_LinesColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ISequenceView::GetLinesColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_LinesColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL ISequenceView::GetShowCommentsBars ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowCommentsBars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutShowCommentsBars ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowCommentsBars(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ISequenceView::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * ISequenceView::GetTextFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_TextFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutTextFont ( IFontDisp * val ) {
    HRESULT _hr = put_TextFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ISequenceView::PutRefTextFont ( IFontDisp * val ) {
    HRESULT _hr = putref_TextFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * ISequenceView::GetCommentsFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_CommentsFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutRefCommentsFont ( IFontDisp * val ) {
    HRESULT _hr = putref_CommentsFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ISequenceView::PutCommentsFont ( IFontDisp * val ) {
    HRESULT _hr = put_CommentsFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * ISequenceView::GetHeaderFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_HeaderFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutRefHeaderFont ( IFontDisp * val ) {
    HRESULT _hr = putref_HeaderFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ISequenceView::PutHeaderFont ( IFontDisp * val ) {
    HRESULT _hr = put_HeaderFont(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetShowItemTipStrips ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowItemTipStrips(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutShowItemTipStrips ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShowItemTipStrips(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SeqViewColumnsPtr ISequenceView::GetColumns ( ) {
    struct SeqViewColumns * _result = 0;
    HRESULT _hr = get_Columns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SeqViewColumnsPtr(_result, false);
}

long ISequenceView::GetMaxCommentsHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxCommentsHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutMaxCommentsHeight ( long val ) {
    HRESULT _hr = put_MaxCommentsHeight(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ISequenceView::GetCursor ( ) {
    long _result = 0;
    HRESULT _hr = get_Cursor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutCursor ( long val ) {
    HRESULT _hr = put_Cursor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetHorizLines ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HorizLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutHorizLines ( VARIANT_BOOL val ) {
    HRESULT _hr = put_HorizLines(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetVertLines ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_VertLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutVertLines ( VARIANT_BOOL val ) {
    HRESULT _hr = put_VertLines(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ISequenceView::GetCommentsOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_CommentsOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutCommentsOffset ( long val ) {
    HRESULT _hr = put_CommentsOffset(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetAutoSizeColumns ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSizeColumns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutAutoSizeColumns ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AutoSizeColumns(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ISequenceView::HitTest ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_HitTest(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t ISequenceView::GetItemBackColorExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ItemBackColorExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ISequenceView::PutItemBackColorExpression ( _bstr_t val ) {
    HRESULT _hr = put_ItemBackColorExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ISequenceView::GetItemTextColorExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ItemTextColorExpression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ISequenceView::PutItemTextColorExpression ( _bstr_t val ) {
    HRESULT _hr = put_ItemTextColorExpression(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT ISequenceView::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long ISequenceView::GetIconSize ( ) {
    long _result = 0;
    HRESULT _hr = get_IconSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutIconSize ( long val ) {
    HRESULT _hr = put_IconSize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources ISequenceView::GetHeaderFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_HeaderFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutHeaderFontSource ( enum FontSources val ) {
    HRESULT _hr = put_HeaderFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources ISequenceView::GetCommentsFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_CommentsFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutCommentsFontSource ( enum FontSources val ) {
    HRESULT _hr = put_CommentsFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources ISequenceView::GetTextFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_TextFontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutTextFontSource ( enum FontSources val ) {
    HRESULT _hr = put_TextFontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetShadeAlternateColumns ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShadeAlternateColumns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutShadeAlternateColumns ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ShadeAlternateColumns(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::GetRoundItemRects ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RoundItemRects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutRoundItemRects ( VARIANT_BOOL val ) {
    HRESULT _hr = put_RoundItemRects(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

BordersPtr ISequenceView::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

VARIANT_BOOL ISequenceView::GetStepIconsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StepIconsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutStepIconsEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_StepIconsEnabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ISequenceView::GetBlockDisplayOptions ( ) {
    long _result = 0;
    HRESULT _hr = get_BlockDisplayOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutBlockDisplayOptions ( long val ) {
    HRESULT _hr = put_BlockDisplayOptions(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ISequenceView::GetEditingFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_EditingFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutEditingFlags ( long val ) {
    HRESULT _hr = put_EditingFlags(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ISequenceView::ItemIndexToStep ( long ItemIndex, enum TS::StepGroups * group, long * stepIndex ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ItemIndexToStep(ItemIndex, group, stepIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long ISequenceView::StepToItemIndex ( enum TS::StepGroups group, long stepIndex ) {
    long _result = 0;
    HRESULT _hr = raw_StepToItemIndex(group, stepIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL ISequenceView::GetCanEditLabel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanEditLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT ISequenceView::EditLabel ( ) {
    HRESULT _hr = raw_EditLabel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ISequenceView::BeginUpdate ( ) {
    HRESULT _hr = raw_BeginUpdate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ISequenceView::EndUpdate ( ) {
    HRESULT _hr = raw_EndUpdate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

long ISequenceView::GetFocusIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_FocusIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceView::PutFocusIndex ( long val ) {
    HRESULT _hr = put_FocusIndex(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface _SequenceViewEvents wrapper method implementations
//

HRESULT _SequenceViewEvents::CursorMoved ( long itemIdx ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", itemIdx);
}

HRESULT _SequenceViewEvents::ColumnResized ( long columnIndex, long newSize ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003", columnIndex, newSize);
}

HRESULT _SequenceViewEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _SequenceViewEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _SequenceViewEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _SequenceViewEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _SequenceViewEvents::DblClick ( ) {
    return _com_dispatch_method(this, DISPID_DBLCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _SequenceViewEvents::CreateContextMenu ( long menuHandle, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003", menuHandle, x, y);
}

HRESULT _SequenceViewEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _SequenceViewEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface SequenceFiles wrapper method implementations
//

TS::SequenceFilePtr SequenceFiles::GetItem ( const _variant_t & fileIndex ) {
    struct TS::SequenceFile * _result = 0;
    HRESULT _hr = get_Item(fileIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceFilePtr(_result, false);
}

IUnknownPtr SequenceFiles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long SequenceFiles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Executions wrapper method implementations
//

TS::ExecutionPtr Executions::GetItem ( long itemIdx ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

IUnknownPtr Executions::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long Executions::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Executions::GetNumIncomplete ( ) {
    long _result = 0;
    HRESULT _hr = get_NumIncomplete(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Executions::GetNumPaused ( ) {
    long _result = 0;
    HRESULT _hr = get_NumPaused(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long Executions::GetNumRunning ( ) {
    long _result = 0;
    HRESULT _hr = get_NumRunning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Executions::ResumeAll ( ) {
    HRESULT _hr = raw_ResumeAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface EntryPoint wrapper method implementations
//

TS::ExecutionPtr EntryPoint::Run ( const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_Run(editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

TS::ExecutionPtr EntryPoint::RunSelectedSteps ( const _variant_t & interactiveArgsVal, const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_RunSelectedSteps(interactiveArgsVal, editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

TS::ExecutionPtr EntryPoint::LoopOnSelectedSteps ( const _variant_t & interactiveArgsVal, const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_LoopOnSelectedSteps(interactiveArgsVal, editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

_bstr_t EntryPoint::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL EntryPoint::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL EntryPoint::GetInteractiveExecutionAllowed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InteractiveExecutionAllowed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TS::SequencePtr EntryPoint::GetSequence ( ) {
    struct TS::Sequence * _result = 0;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequencePtr(_result, false);
}

//
// interface EntryPoints wrapper method implementations
//

EntryPointPtr EntryPoints::GetItem ( const _variant_t & entryPointIndexParam ) {
    struct EntryPoint * _result = 0;
    HRESULT _hr = get_Item(entryPointIndexParam, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointPtr(_result, false);
}

IUnknownPtr EntryPoints::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long EntryPoints::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// dispinterface _ApplicationMgrEvents wrapper method implementations
//

HRESULT _ApplicationMgrEvents::ExitApplication ( ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ApplicationMgrEvents::UIMessageEvent ( struct TS::UIMessage * uiMsg, VARIANT_BOOL * cancel ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", uiMsg, cancel);
}

HRESULT _ApplicationMgrEvents::SequenceFileOpened ( struct TS::SequenceFile * file, VARIANT_BOOL alreadyLoaded ) {
    return _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x000b", file, alreadyLoaded);
}

HRESULT _ApplicationMgrEvents::SequenceFileClosed ( _bstr_t pathName ) {
    return _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008", (BSTR)pathName);
}

HRESULT _ApplicationMgrEvents::UserChanged ( struct TS::User * user ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", user);
}

HRESULT _ApplicationMgrEvents::Wait ( VARIANT_BOOL showWait ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000b", showWait);
}

HRESULT _ApplicationMgrEvents::ReportError ( long errorCode, _bstr_t errorMessage ) {
    return _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0008", errorCode, (BSTR)errorMessage);
}

HRESULT _ApplicationMgrEvents::PreCommandExecute ( struct Command * Command, VARIANT_BOOL * cancel ) {
    return _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", Command, cancel);
}

HRESULT _ApplicationMgrEvents::PostCommandExecute ( struct Command * Command ) {
    return _com_dispatch_method(this, 0x18, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Command);
}

HRESULT _ApplicationMgrEvents::QueryCloseExecution ( struct TS::Execution * exec, enum TS::ExecutionRunStates RunState, enum QueryCloseExecutionOptions * opt ) {
    return _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003\x4003", exec, RunState, opt);
}

HRESULT _ApplicationMgrEvents::ExecutionClosed ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0xe, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ApplicationMgrEvents::QueryCloseSequenceFile ( struct TS::SequenceFile * file, VARIANT_BOOL * cancel ) {
    return _com_dispatch_method(this, 0xf, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", file, cancel);
}

HRESULT _ApplicationMgrEvents::QueryShutdown ( enum QueryShutdownOptions * opt ) {
    return _com_dispatch_method(this, 0x10, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4003", opt);
}

HRESULT _ApplicationMgrEvents::DisplaySequenceFile ( struct TS::SequenceFile * file, enum SequenceFileDisplayReasons reason ) {
    return _com_dispatch_method(this, 0x15, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003", file, reason);
}

HRESULT _ApplicationMgrEvents::DisplayExecution ( struct TS::Execution * exec, enum ExecutionDisplayReasons reason ) {
    return _com_dispatch_method(this, 0x16, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003", exec, reason);
}

HRESULT _ApplicationMgrEvents::DisplayReport ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0x17, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ApplicationMgrEvents::AfterUIMessageEvent ( struct TS::UIMessage * uiMsg ) {
    return _com_dispatch_method(this, 0x19, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", uiMsg);
}

HRESULT _ApplicationMgrEvents::ShutDownCompleted ( ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ApplicationMgrEvents::ShutDownCancelled ( ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ApplicationMgrEvents::StartExecution ( struct TS::Execution * exec, struct TS::Thread * thrd, VARIANT_BOOL initiallyHidden ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009\x000b", exec, thrd, initiallyHidden);
}

HRESULT _ApplicationMgrEvents::EndExecution ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ApplicationMgrEvents::BreakOnRunTimeError ( struct TS::Execution * exec, struct TS::Thread * initiatingThread, VARIANT_BOOL * showDialog, VARIANT_BOOL * BreakExecution ) {
    return _com_dispatch_method(this, 0x11, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009\x400b\x400b", exec, initiatingThread, showDialog, BreakExecution);
}

HRESULT _ApplicationMgrEvents::UserMessage ( struct TS::UIMessage * uiMsg ) {
    return _com_dispatch_method(this, 0x12, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", uiMsg);
}

HRESULT _ApplicationMgrEvents::RefreshWindows ( IUnknown * activeXData ) {
    return _com_dispatch_method(this, 0x13, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000d", activeXData);
}

HRESULT _ApplicationMgrEvents::Break ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0x14, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ApplicationMgrEvents::QueryReloadSequenceFile ( struct TS::SequenceFile * file, enum QueryReloadSequenceFileOptions * opt ) {
    return _com_dispatch_method(this, 0x28, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x4003", file, opt);
}

HRESULT _ApplicationMgrEvents::ProcessUserCommands ( struct Strings * cmds ) {
    return _com_dispatch_method(this, 0x29, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", cmds);
}

HRESULT _ApplicationMgrEvents::EditModeChanged ( ) {
    return _com_dispatch_method(this, 0x2a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ApplicationMgrEvents::ProcessUserCommandLineArguments ( VARIANT_BOOL processCommand, struct Strings * arguments, long * currentArgument, enum ProcessCommandLineErrors * errorProcessing, BSTR * errorMessage ) {
    return _com_dispatch_method(this, 0x2b, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000b\x0009\x4003\x4003\x4008", processCommand, arguments, currentArgument, errorProcessing, errorMessage);
}

HRESULT _ApplicationMgrEvents::CanEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind, VARIANT_BOOL * canEditValue, long * editDenialReasons ) {
    return _com_dispatch_method(this, 0x2c, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003\x400b\x4003", editedFile, editKind, canEditValue, editDenialReasons);
}

HRESULT _ApplicationMgrEvents::BeginEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind, struct TS::PropertyObject * objectsToEdit, VARIANT_BOOL * cancel, long * editDenialReasons ) {
    return _com_dispatch_method(this, 0x2d, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003\x0009\x400b\x4003", editedFile, editKind, objectsToEdit, cancel, editDenialReasons);
}

HRESULT _ApplicationMgrEvents::EndEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind, struct TS::PropertyObject * editedObjects, VARIANT_BOOL cancelled ) {
    return _com_dispatch_method(this, 0x2e, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003\x0009\x000b", editedFile, editKind, editedObjects, cancelled);
}

HRESULT _ApplicationMgrEvents::DropFile ( _bstr_t file, VARIANT_BOOL * handled ) {
    return _com_dispatch_method(this, 0x2f, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x400b", (BSTR)file, handled);
}

HRESULT _ApplicationMgrEvents::SequenceFileClosing ( struct TS::SequenceFile * file ) {
    return _com_dispatch_method(this, 0x30, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", file);
}

//
// dispinterface _SequenceFileViewMgrEvents wrapper method implementations
//

HRESULT _SequenceFileViewMgrEvents::SequenceFileChanged ( struct TS::SequenceFile * newFile ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", newFile);
}

HRESULT _SequenceFileViewMgrEvents::SelectionChanged ( ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _SequenceFileViewMgrEvents::SequenceChanged ( struct TS::Sequence * newSequence ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", newSequence);
}

HRESULT _SequenceFileViewMgrEvents::StepGroupChanged ( enum TS::StepGroups newGroup ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", newGroup);
}

HRESULT _SequenceFileViewMgrEvents::RefreshWindow ( ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _SequenceFileViewMgrEvents::SequenceSelectionChanged ( ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _SequenceFileViewMgrEvents::PropertyObjectSelectionChanged ( ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//
// dispinterface _ExecutionViewMgrEvents wrapper method implementations
//

HRESULT _ExecutionViewMgrEvents::ExecutionChanged ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ExecutionViewMgrEvents::RunStateChanged ( enum TS::ExecutionRunStates newRunState ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", newRunState);
}

HRESULT _ExecutionViewMgrEvents::EndExecution ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ExecutionViewMgrEvents::TerminationStateChanged ( enum TS::ExecutionTerminationStates newTermState ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", newTermState);
}

HRESULT _ExecutionViewMgrEvents::SelectionChanged ( ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _ExecutionViewMgrEvents::UserMessage ( struct TS::UIMessage * uiMsg ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", uiMsg);
}

HRESULT _ExecutionViewMgrEvents::RefreshWindow ( struct TS::SequenceContext * ctxt ) {
    return _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", ctxt);
}

HRESULT _ExecutionViewMgrEvents::Break ( struct TS::Execution * exec, struct TS::Thread * thrd, struct TS::SequenceContext * ctxt ) {
    return _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009\x0009", exec, thrd, ctxt);
}

HRESULT _ExecutionViewMgrEvents::Trace ( struct TS::Execution * exec, struct TS::Thread * thrd, struct TS::SequenceContext * ctxt ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009\x0009", exec, thrd, ctxt);
}

HRESULT _ExecutionViewMgrEvents::DisplayReport ( struct TS::Execution * exec ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", exec);
}

HRESULT _ExecutionViewMgrEvents::ContextChanged ( struct TS::SequenceContext * ctxt ) {
    return _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", ctxt);
}

HRESULT _ExecutionViewMgrEvents::ThreadChanged ( struct TS::Thread * thrd ) {
    return _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", thrd);
}

HRESULT _ExecutionViewMgrEvents::PropertyObjectSelectionChanged ( ) {
    return _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//
// interface ICheckBox wrapper method implementations
//

VARIANT_BOOL ICheckBox::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IFontDisp * ICheckBox::GetFont ( ) {
    IFontDisp * _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutFont ( IFontDisp * val ) {
    HRESULT _hr = put_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ICheckBox::PutRefFont ( IFontDisp * val ) {
    HRESULT _hr = putref_Font(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ICheckBox::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutBackColor ( OLE_COLOR val ) {
    HRESULT _hr = put_BackColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ICheckBox::GetForeColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ForeColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutForeColor ( OLE_COLOR val ) {
    HRESULT _hr = put_ForeColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t ICheckBox::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void ICheckBox::PutCaption ( _bstr_t val ) {
    HRESULT _hr = put_Caption(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long ICheckBox::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IPictureDisp * ICheckBox::GetImage ( ) {
    IPictureDisp * _result = 0;
    HRESULT _hr = get_Image(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutImage ( IPictureDisp * val ) {
    HRESULT _hr = put_Image(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

void ICheckBox::PutRefImage ( IPictureDisp * val ) {
    HRESULT _hr = putref_Image(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ContentAlignmentStyles ICheckBox::GetTextAlign ( ) {
    enum ContentAlignmentStyles _result;
    HRESULT _hr = get_TextAlign(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutTextAlign ( enum ContentAlignmentStyles val ) {
    HRESULT _hr = put_TextAlign(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ICheckBox::GetChecked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Checked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutChecked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Checked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ICheckBox::GetUseMaskColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMaskColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutUseMaskColor ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseMaskColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

OLE_COLOR ICheckBox::GetMaskColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_MaskColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutMaskColor ( OLE_COLOR val ) {
    HRESULT _hr = put_MaskColor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum CheckBoxStyles ICheckBox::GetStyle ( ) {
    enum CheckBoxStyles _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutStyle ( enum CheckBoxStyles val ) {
    HRESULT _hr = put_Style(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum FontSources ICheckBox::GetFontSource ( ) {
    enum FontSources _result;
    HRESULT _hr = get_FontSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutFontSource ( enum FontSources val ) {
    HRESULT _hr = put_FontSource(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL ICheckBox::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ContentAlignmentStyles ICheckBox::GetImageAlign ( ) {
    enum ContentAlignmentStyles _result;
    HRESULT _hr = get_ImageAlign(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ICheckBox::PutImageAlign ( enum ContentAlignmentStyles val ) {
    HRESULT _hr = put_ImageAlign(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT ICheckBox::Localize ( _bstr_t sectionName ) {
    HRESULT _hr = raw_Localize(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// dispinterface _CheckBoxEvents wrapper method implementations
//

HRESULT _CheckBoxEvents::Click ( ) {
    return _com_dispatch_method(this, DISPID_CLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

HRESULT _CheckBoxEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

HRESULT _CheckBoxEvents::KeyPress ( short * keyAscii ) {
    return _com_dispatch_method(this, DISPID_KEYPRESS, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002", keyAscii);
}

HRESULT _CheckBoxEvents::KeyUp ( short keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002", keyCode, shift);
}

HRESULT _CheckBoxEvents::MouseDown ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _CheckBoxEvents::MouseMove ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _CheckBoxEvents::MouseUp ( short btn, short shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y ) {
    return _com_dispatch_method(this, DISPID_MOUSEUP, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0002\x0002\x0003\x0003", btn, shift, x, y);
}

HRESULT _CheckBoxEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

//
// interface IVariablesView wrapper method implementations
//

VARIANT_BOOL IVariablesView::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IVariablesView::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IVariablesView::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IVariablesView::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IVariablesView::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

BordersPtr IVariablesView::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

//
// dispinterface _VariablesViewEvents wrapper method implementations
//

HRESULT _VariablesViewEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _VariablesViewEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

HRESULT _VariablesViewEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

//
// interface InsertionPalettePage wrapper method implementations
//

long InsertionPalettePage::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL InsertionPalettePage::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InsertionPalettePage::PutVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Visible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

float InsertionPalettePage::GetSplitterRatio ( ) {
    float _result = 0;
    HRESULT _hr = get_SplitterRatio(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InsertionPalettePage::PutSplitterRatio ( float ratio ) {
    HRESULT _hr = put_SplitterRatio(ratio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL InsertionPalettePage::GetExpanded ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Expanded(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void InsertionPalettePage::PutExpanded ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Expanded(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface InsertionPalettePages wrapper method implementations
//

InsertionPalettePagePtr InsertionPalettePages::GetItem ( long itemIdx ) {
    struct InsertionPalettePage * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InsertionPalettePagePtr(_result, false);
}

IUnknownPtr InsertionPalettePages::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long InsertionPalettePages::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IInsertionPalette wrapper method implementations
//

VARIANT_BOOL IInsertionPalette::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IInsertionPalette::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IInsertionPalette::GethWnd ( ) {
    long _result = 0;
    HRESULT _hr = get_hWnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

BordersPtr IInsertionPalette::GetBorders ( ) {
    struct Borders * _result = 0;
    HRESULT _hr = get_Borders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return BordersPtr(_result, false);
}

VARIANT_BOOL IInsertionPalette::GetScaleWithDPI ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithDPI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IInsertionPalette::PutScaleWithDPI ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ScaleWithDPI(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IInsertionPalette::GetAllowEditing ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowEditing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IInsertionPalette::PutAllowEditing ( VARIANT_BOOL val ) {
    HRESULT _hr = put_AllowEditing(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IInsertionPalette::GetPaletteLayout ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PaletteLayout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IInsertionPalette::PutPaletteLayout ( _bstr_t val ) {
    HRESULT _hr = put_PaletteLayout(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

InsertionPalettePagesPtr IInsertionPalette::GetPages ( ) {
    struct InsertionPalettePages * _result = 0;
    HRESULT _hr = get_Pages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InsertionPalettePagesPtr(_result, false);
}

//
// dispinterface _InsertionPaletteEvents wrapper method implementations
//

HRESULT _InsertionPaletteEvents::BorderDragged ( long bordersChanged, OLE_XPOS_PIXELS newX, OLE_YPOS_PIXELS newY, OLE_XPOS_PIXELS newWidth, OLE_YPOS_PIXELS newHeight, VARIANT_BOOL finalResize ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003\x0003\x000b", bordersChanged, newX, newY, newWidth, newHeight, finalResize);
}

HRESULT _InsertionPaletteEvents::ConnectionActivity ( enum ConnectionActivityTypes activity ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", activity);
}

HRESULT _InsertionPaletteEvents::KeyDown ( short * keyCode, short shift ) {
    return _com_dispatch_method(this, DISPID_KEYDOWN, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x4002\x0002", keyCode, shift);
}

//
// interface ISequenceFileViewMgr wrapper method implementations
//

SequenceFileViewMgrConnectionsPtr ISequenceFileViewMgr::GetConnections ( ) {
    struct SequenceFileViewMgrConnections * _result = 0;
    HRESULT _hr = get_Connections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileViewMgrConnectionsPtr(_result, false);
}

EntryPointsPtr ISequenceFileViewMgr::GetExecutionEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ExecutionEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

TS::SequenceFilePtr ISequenceFileViewMgr::GetSequenceFile ( ) {
    struct TS::SequenceFile * _result = 0;
    HRESULT _hr = get_SequenceFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceFilePtr(_result, false);
}

void ISequenceFileViewMgr::PutRefSequenceFile ( struct TS::SequenceFile * val ) {
    HRESULT _hr = putref_SequenceFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::SequencePtr ISequenceFileViewMgr::GetSequence ( ) {
    struct TS::Sequence * _result = 0;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequencePtr(_result, false);
}

void ISequenceFileViewMgr::PutRefSequence ( struct TS::Sequence * val ) {
    HRESULT _hr = putref_Sequence(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TS::StepGroups ISequenceFileViewMgr::GetStepGroup ( ) {
    enum TS::StepGroups _result;
    HRESULT _hr = get_StepGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceFileViewMgr::PutStepGroup ( enum TS::StepGroups val ) {
    HRESULT _hr = put_StepGroup(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

EntryPointsPtr ISequenceFileViewMgr::GetConfigurationEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ConfigurationEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

SelectedStepsPtr ISequenceFileViewMgr::GetSelectedSteps ( ) {
    struct SelectedSteps * _result = 0;
    HRESULT _hr = get_SelectedSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedStepsPtr(_result, false);
}

VARIANT_BOOL ISequenceFileViewMgr::GetReplaceSequenceFileOnClose ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReplaceSequenceFileOnClose(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceFileViewMgr::PutReplaceSequenceFileOnClose ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ReplaceSequenceFileOnClose(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IDispatchPtr ISequenceFileViewMgr::GetApplicationMgr ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_ApplicationMgr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

_variant_t ISequenceFileViewMgr::GetUserData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void ISequenceFileViewMgr::PutUserData ( const _variant_t & val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::EditArgsPtr ISequenceFileViewMgr::BuildEditArgs ( ) {
    struct TS::EditArgs * _result = 0;
    HRESULT _hr = raw_BuildEditArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::EditArgsPtr(_result, false);
}

HRESULT ISequenceFileViewMgr::SetSequenceAndGroup ( struct TS::Sequence * newSequence, enum TS::StepGroups newGroup ) {
    HRESULT _hr = raw_SetSequenceAndGroup(newSequence, newGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::ExecutionPtr ISequenceFileViewMgr::Run ( const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_Run(editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

TS::ExecutionPtr ISequenceFileViewMgr::RunSelectedSteps ( const _variant_t & interactiveArgsVal, const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_RunSelectedSteps(interactiveArgsVal, editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

TS::InteractiveArgsPtr ISequenceFileViewMgr::BuildInteractiveArgs ( const _variant_t & createLoopArgs, VARIANT * cancel ) {
    struct TS::InteractiveArgs * _result = 0;
    HRESULT _hr = raw_BuildInteractiveArgs(createLoopArgs, cancel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::InteractiveArgsPtr(_result, false);
}

TS::ExecutionPtr ISequenceFileViewMgr::LoopOnSelectedSteps ( const _variant_t & interactiveArgsVal, const _variant_t & editArgsVal ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = raw_LoopOnSelectedSteps(interactiveArgsVal, editArgsVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

HRESULT ISequenceFileViewMgr::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT ISequenceFileViewMgr::RefreshStep ( long stepIndex ) {
    HRESULT _hr = raw_RefreshStep(stepIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

CommandPtr ISequenceFileViewMgr::GetCommand ( enum CommandKinds cmdKind, long Index ) {
    struct Command * _result = 0;
    HRESULT _hr = raw_GetCommand(cmdKind, Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandPtr(_result, false);
}

_bstr_t ISequenceFileViewMgr::GetCaptionText ( enum CaptionSources captionSource, VARIANT_BOOL longName, _bstr_t formatExpression ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCaptionText(captionSource, longName, formatExpression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t ISequenceFileViewMgr::GetImageName ( enum ImageSources imageSource ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetImageName(imageSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

CommandConnectionPtr ISequenceFileViewMgr::ConnectCommand ( IDispatch * uiObj, enum CommandKinds cmdKind, long Index, long opts ) {
    struct CommandConnection * _result = 0;
    HRESULT _hr = raw_ConnectCommand(uiObj, cmdKind, Index, opts, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandConnectionPtr(_result, false);
}

CaptionConnectionPtr ISequenceFileViewMgr::ConnectCaption ( IDispatch * uiObj, enum CaptionSources captionSource, VARIANT_BOOL longName ) {
    struct CaptionConnection * _result = 0;
    HRESULT _hr = raw_ConnectCaption(uiObj, captionSource, longName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CaptionConnectionPtr(_result, false);
}

SequenceFileListConnectionPtr ISequenceFileViewMgr::ConnectSequenceFileList ( IDispatch * uiObj, VARIANT_BOOL fullPath ) {
    struct SequenceFileListConnection * _result = 0;
    HRESULT _hr = raw_ConnectSequenceFileList(uiObj, fullPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFileListConnectionPtr(_result, false);
}

SequenceListConnectionPtr ISequenceFileViewMgr::ConnectSequenceList ( IDispatch * uiObj ) {
    struct SequenceListConnection * _result = 0;
    HRESULT _hr = raw_ConnectSequenceList(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceListConnectionPtr(_result, false);
}

StepGroupListConnectionPtr ISequenceFileViewMgr::ConnectStepGroupList ( IDispatch * uiObj ) {
    struct StepGroupListConnection * _result = 0;
    HRESULT _hr = raw_ConnectStepGroupList(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StepGroupListConnectionPtr(_result, false);
}

SequenceViewConnectionPtr ISequenceFileViewMgr::ConnectSequenceView ( IDispatch * uiObj ) {
    struct SequenceViewConnection * _result = 0;
    HRESULT _hr = raw_ConnectSequenceView(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceViewConnectionPtr(_result, false);
}

ImageConnectionPtr ISequenceFileViewMgr::ConnectImage ( IDispatch * uiObj, enum ImageSources imageSource ) {
    struct ImageConnection * _result = 0;
    HRESULT _hr = raw_ConnectImage(uiObj, imageSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ImageConnectionPtr(_result, false);
}

enum StepGroupModes ISequenceFileViewMgr::GetStepGroupMode ( ) {
    enum StepGroupModes _result;
    HRESULT _hr = get_StepGroupMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void ISequenceFileViewMgr::PutStepGroupMode ( enum StepGroupModes val ) {
    HRESULT _hr = put_StepGroupMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::UndoStackPtr ISequenceFileViewMgr::GetUndoStack ( ) {
    struct TS::UndoStack * _result = 0;
    HRESULT _hr = get_UndoStack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::UndoStackPtr(_result, false);
}

SelectedSequencesPtr ISequenceFileViewMgr::GetSelectedSequences ( ) {
    struct SelectedSequences * _result = 0;
    HRESULT _hr = get_SelectedSequences(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedSequencesPtr(_result, false);
}

SelectedPropertyObjectsPtr ISequenceFileViewMgr::GetSelectedPropertyObjects ( ) {
    struct SelectedPropertyObjects * _result = 0;
    HRESULT _hr = get_SelectedPropertyObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedPropertyObjectsPtr(_result, false);
}

HRESULT ISequenceFileViewMgr::RefreshStepEx ( enum TS::StepGroups group, long stepIndex ) {
    HRESULT _hr = raw_RefreshStepEx(group, stepIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::SequenceContextPtr ISequenceFileViewMgr::NewEditContext ( ) {
    struct TS::SequenceContext * _result = 0;
    HRESULT _hr = raw_NewEditContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceContextPtr(_result, false);
}

VariablesConnectionPtr ISequenceFileViewMgr::ConnectVariables ( IDispatch * uiObj ) {
    struct VariablesConnection * _result = 0;
    HRESULT _hr = raw_ConnectVariables(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return VariablesConnectionPtr(_result, false);
}

InsertionPaletteConnectionPtr ISequenceFileViewMgr::ConnectInsertionPalette ( IDispatch * uiObj ) {
    struct InsertionPaletteConnection * _result = 0;
    HRESULT _hr = raw_ConnectInsertionPalette(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return InsertionPaletteConnectionPtr(_result, false);
}

//
// interface Command wrapper method implementations
//

VARIANT_BOOL Command::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutEnabled ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Enabled(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Command::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutVisible ( VARIANT_BOOL val ) {
    HRESULT _hr = put_Visible(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Command::GetIsSeparator ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSeparator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutIsSeparator ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IsSeparator(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Command::GetIsToggle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsToggle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutIsToggle ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IsToggle(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Command::GetToggleState ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ToggleState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutToggleState ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ToggleState(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ShortcutKeys Command::GetShortcutKey ( ) {
    enum ShortcutKeys _result;
    HRESULT _hr = get_ShortcutKey(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutShortcutKey ( enum ShortcutKeys val ) {
    HRESULT _hr = put_ShortcutKey(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Command::GetShortcutModifier ( ) {
    long _result = 0;
    HRESULT _hr = get_ShortcutModifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutShortcutModifier ( long val ) {
    HRESULT _hr = put_ShortcutModifier(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t Command::GetUserData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void Command::PutUserData ( const _variant_t & val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IUnknownPtr Command::GetUserObject ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get_UserObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

void Command::PutRefUserObject ( IUnknown * val ) {
    HRESULT _hr = putref_UserObject(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ISequenceFileViewMgrPtr Command::GetSequenceFileViewMgr ( ) {
    struct ISequenceFileViewMgr * _result = 0;
    HRESULT _hr = get_SequenceFileViewMgr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISequenceFileViewMgrPtr(_result, false);
}

void Command::PutRefSequenceFileViewMgr ( struct ISequenceFileViewMgr * val ) {
    HRESULT _hr = putref_SequenceFileViewMgr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IExecutionViewMgrPtr Command::GetExecutionViewMgr ( ) {
    struct IExecutionViewMgr * _result = 0;
    HRESULT _hr = get_ExecutionViewMgr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IExecutionViewMgrPtr(_result, false);
}

void Command::PutRefExecutionViewMgr ( struct IExecutionViewMgr * val ) {
    HRESULT _hr = putref_ExecutionViewMgr(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum CommandKinds Command::GetKind ( ) {
    enum CommandKinds _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

CommandsPtr Command::GetSubsidiaryCommands ( ) {
    struct Commands * _result = 0;
    HRESULT _hr = get_SubsidiaryCommands(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandsPtr(_result, false);
}

void Command::PutRefSubsidiaryCommands ( struct Commands * val ) {
    HRESULT _hr = putref_SubsidiaryCommands(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Command::GetDisplayName ( _bstr_t acceleratorPrefix, VARIANT_BOOL includeShortcutText ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDisplayName(acceleratorPrefix, includeShortcutText, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT Command::SetDisplayName ( _bstr_t val ) {
    HRESULT _hr = raw_SetDisplayName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Command::Execute ( VARIANT_BOOL applicationHandlesError ) {
    HRESULT _hr = raw_Execute(applicationHandlesError);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t Command::GetLVShortcutKey ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LVShortcutKey(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Command::PutLVShortcutKey ( _bstr_t val ) {
    HRESULT _hr = put_LVShortcutKey(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL Command::GetLVShortcutModifier ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LVShortcutModifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void Command::PutLVShortcutModifier ( VARIANT_BOOL val ) {
    HRESULT _hr = put_LVShortcutModifier(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t Command::GetIconName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IconName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void Command::PutIconName ( _bstr_t val ) {
    HRESULT _hr = put_IconName(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long Command::GetEntryPointIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_EntryPointIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

EntryPointPtr Command::GetEntryPoint ( ) {
    struct EntryPoint * _result = 0;
    HRESULT _hr = get_EntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointPtr(_result, false);
}

//
// interface IExecutionViewMgr wrapper method implementations
//

TS::ExecutionPtr IExecutionViewMgr::GetExecution ( ) {
    struct TS::Execution * _result = 0;
    HRESULT _hr = get_Execution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ExecutionPtr(_result, false);
}

void IExecutionViewMgr::PutRefExecution ( struct TS::Execution * val ) {
    HRESULT _hr = putref_Execution(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ExecutionViewMgrConnectionsPtr IExecutionViewMgr::GetConnections ( ) {
    struct ExecutionViewMgrConnections * _result = 0;
    HRESULT _hr = get_Connections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionViewMgrConnectionsPtr(_result, false);
}

enum TS::ExecutionRunStates IExecutionViewMgr::GetRunState ( ) {
    enum TS::ExecutionRunStates _result;
    HRESULT _hr = get_RunState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum TS::ExecutionTerminationStates IExecutionViewMgr::GetTerminationState ( ) {
    enum TS::ExecutionTerminationStates _result;
    HRESULT _hr = get_TerminationState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

EntryPointsPtr IExecutionViewMgr::GetExecutionEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ExecutionEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

EntryPointsPtr IExecutionViewMgr::GetConfigurationEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ConfigurationEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

SelectedStepsPtr IExecutionViewMgr::GetSelectedSteps ( ) {
    struct SelectedSteps * _result = 0;
    HRESULT _hr = get_SelectedSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedStepsPtr(_result, false);
}

TS::SequenceContextPtr IExecutionViewMgr::GetSequenceContext ( ) {
    struct TS::SequenceContext * _result = 0;
    HRESULT _hr = get_SequenceContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceContextPtr(_result, false);
}

void IExecutionViewMgr::PutRefSequenceContext ( struct TS::SequenceContext * val ) {
    HRESULT _hr = putref_SequenceContext(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::ThreadPtr IExecutionViewMgr::GetThread ( ) {
    struct TS::Thread * _result = 0;
    HRESULT _hr = get_Thread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::ThreadPtr(_result, false);
}

void IExecutionViewMgr::PutRefThread ( struct TS::Thread * val ) {
    HRESULT _hr = putref_Thread(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IExecutionViewMgr::GetReplaceExecutionOnClose ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReplaceExecutionOnClose(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExecutionViewMgr::PutReplaceExecutionOnClose ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ReplaceExecutionOnClose(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IDispatchPtr IExecutionViewMgr::GetApplicationMgr ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_ApplicationMgr(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

_variant_t IExecutionViewMgr::GetUserData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IExecutionViewMgr::PutUserData ( const _variant_t & val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IExecutionViewMgr::TerminateExecution ( ) {
    HRESULT _hr = raw_TerminateExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::BreakExecution ( ) {
    HRESULT _hr = raw_BreakExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::ResumeExecution ( ) {
    HRESULT _hr = raw_ResumeExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::RestartExecution ( ) {
    HRESULT _hr = raw_RestartExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::AbortExecution ( ) {
    HRESULT _hr = raw_AbortExecution();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::EditArgsPtr IExecutionViewMgr::BuildEditArgs ( ) {
    struct TS::EditArgs * _result = 0;
    HRESULT _hr = raw_BuildEditArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::EditArgsPtr(_result, false);
}

TS::InteractiveArgsPtr IExecutionViewMgr::BuildInteractiveArgs ( const _variant_t & createLoopArgs, VARIANT * cancel ) {
    struct TS::InteractiveArgs * _result = 0;
    HRESULT _hr = raw_BuildInteractiveArgs(createLoopArgs, cancel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::InteractiveArgsPtr(_result, false);
}

HRESULT IExecutionViewMgr::Refresh ( const _variant_t & seqCtxt ) {
    HRESULT _hr = raw_Refresh(seqCtxt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::RefreshStep ( long stepIndex ) {
    HRESULT _hr = raw_RefreshStep(stepIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

CommandPtr IExecutionViewMgr::GetCommand ( enum CommandKinds cmdKind, long commandIndex ) {
    struct Command * _result = 0;
    HRESULT _hr = raw_GetCommand(cmdKind, commandIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandPtr(_result, false);
}

_bstr_t IExecutionViewMgr::GetCaptionText ( enum CaptionSources captionSource, VARIANT_BOOL longName, _bstr_t formatExpression ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCaptionText(captionSource, longName, formatExpression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IExecutionViewMgr::GetImageName ( enum ImageSources imageSource ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetImageName(imageSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

double IExecutionViewMgr::GetNumericValue ( enum NumericSources numericSource ) {
    double _result = 0;
    HRESULT _hr = raw_GetNumericValue(numericSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IExecutionViewMgr::RunSelectedSteps ( const _variant_t & interArgs ) {
    HRESULT _hr = raw_RunSelectedSteps(interArgs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IExecutionViewMgr::LoopOnSelectedSteps ( const _variant_t & interArgs ) {
    HRESULT _hr = raw_LoopOnSelectedSteps(interArgs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

CommandConnectionPtr IExecutionViewMgr::ConnectCommand ( IDispatch * uiObj, enum CommandKinds cmdKind, long Index, long opts ) {
    struct CommandConnection * _result = 0;
    HRESULT _hr = raw_ConnectCommand(uiObj, cmdKind, Index, opts, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandConnectionPtr(_result, false);
}

CaptionConnectionPtr IExecutionViewMgr::ConnectCaption ( IDispatch * uiObj, enum CaptionSources captionSource, VARIANT_BOOL longName ) {
    struct CaptionConnection * _result = 0;
    HRESULT _hr = raw_ConnectCaption(uiObj, captionSource, longName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CaptionConnectionPtr(_result, false);
}

ExecutionViewConnectionPtr IExecutionViewMgr::ConnectExecutionView ( IDispatch * uiObj, long opts ) {
    struct ExecutionViewConnection * _result = 0;
    HRESULT _hr = raw_ConnectExecutionView(uiObj, opts, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionViewConnectionPtr(_result, false);
}

ReportViewConnectionPtr IExecutionViewMgr::ConnectReportView ( IDispatch * uiObj ) {
    struct ReportViewConnection * _result = 0;
    HRESULT _hr = raw_ConnectReportView(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ReportViewConnectionPtr(_result, false);
}

ExecutionListConnectionPtr IExecutionViewMgr::ConnectExecutionList ( IDispatch * uiObj ) {
    struct ExecutionListConnection * _result = 0;
    HRESULT _hr = raw_ConnectExecutionList(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionListConnectionPtr(_result, false);
}

CallStackConnectionPtr IExecutionViewMgr::ConnectCallStack ( IDispatch * uiObj ) {
    struct CallStackConnection * _result = 0;
    HRESULT _hr = raw_ConnectCallStack(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CallStackConnectionPtr(_result, false);
}

ThreadListConnectionPtr IExecutionViewMgr::ConnectThreadList ( IDispatch * uiObj ) {
    struct ThreadListConnection * _result = 0;
    HRESULT _hr = raw_ConnectThreadList(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ThreadListConnectionPtr(_result, false);
}

ImageConnectionPtr IExecutionViewMgr::ConnectImage ( IDispatch * uiObj, enum ImageSources imageSource ) {
    struct ImageConnection * _result = 0;
    HRESULT _hr = raw_ConnectImage(uiObj, imageSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ImageConnectionPtr(_result, false);
}

NumericConnectionPtr IExecutionViewMgr::ConnectNumeric ( IDispatch * uiObj, enum NumericSources numericSource ) {
    struct NumericConnection * _result = 0;
    HRESULT _hr = raw_ConnectNumeric(uiObj, numericSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return NumericConnectionPtr(_result, false);
}

enum StepGroupModes IExecutionViewMgr::GetStepGroupMode ( ) {
    enum StepGroupModes _result;
    HRESULT _hr = get_StepGroupMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IExecutionViewMgr::PutStepGroupMode ( enum StepGroupModes val ) {
    HRESULT _hr = put_StepGroupMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SelectedPropertyObjectsPtr IExecutionViewMgr::GetSelectedPropertyObjects ( ) {
    struct SelectedPropertyObjects * _result = 0;
    HRESULT _hr = get_SelectedPropertyObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedPropertyObjectsPtr(_result, false);
}

HRESULT IExecutionViewMgr::RefreshStepEx ( enum TS::StepGroups group, long stepIndex ) {
    HRESULT _hr = raw_RefreshStepEx(group, stepIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::SequenceContextPtr IExecutionViewMgr::NewEditContext ( ) {
    struct TS::SequenceContext * _result = 0;
    HRESULT _hr = raw_NewEditContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceContextPtr(_result, false);
}

VariablesConnectionPtr IExecutionViewMgr::ConnectVariables ( IDispatch * uiObj ) {
    struct VariablesConnection * _result = 0;
    HRESULT _hr = raw_ConnectVariables(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return VariablesConnectionPtr(_result, false);
}

//
// interface Commands wrapper method implementations
//

CommandPtr Commands::GetItem ( long itemIdx ) {
    struct Command * _result = 0;
    HRESULT _hr = get_Item(itemIdx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandPtr(_result, false);
}

IUnknownPtr Commands::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long Commands::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT Commands::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Commands::Remove ( long itemIdx ) {
    HRESULT _hr = raw_Remove(itemIdx);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Commands::Insert ( struct Command * Item, long insertBefore ) {
    HRESULT _hr = raw_Insert(Item, insertBefore);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Commands::InsertKind ( enum CommandKinds cmdKind, IDispatch * managerControl, long insertBefore, _bstr_t currentMenuName, _bstr_t allMenuNames, long * numInserted ) {
    HRESULT _hr = raw_InsertKind(cmdKind, managerControl, insertBefore, currentMenuName, allMenuNames, numInserted);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT Commands::InsertIntoWin32Menu ( long menuHandle, long menuItemToInsertBefore, VARIANT_BOOL byPosition, VARIANT_BOOL useShortcutKeys ) {
    HRESULT _hr = raw_InsertIntoWin32Menu(menuHandle, menuItemToInsertBefore, byPosition, useShortcutKeys);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IApplicationMgr wrapper method implementations
//

HRESULT IApplicationMgr::Start ( ) {
    HRESULT _hr = raw_Start();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::Shutdown ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Shutdown(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IApplicationMgr::Login ( ) {
    HRESULT _hr = raw_Login();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::Logout ( ) {
    HRESULT _hr = raw_Logout();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::CloseAllSequenceFiles ( ) {
    HRESULT _hr = raw_CloseAllSequenceFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

TS::SequenceFilePtr IApplicationMgr::OpenSequenceFile ( _bstr_t sequenceFilePath ) {
    struct TS::SequenceFile * _result = 0;
    HRESULT _hr = raw_OpenSequenceFile(sequenceFilePath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceFilePtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::CloseSequenceFile ( struct TS::SequenceFile * file ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CloseSequenceFile(file, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TS::SequenceFilePtr IApplicationMgr::OpenSequenceFileDialog ( ) {
    struct TS::SequenceFile * _result = 0;
    HRESULT _hr = raw_OpenSequenceFileDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceFilePtr(_result, false);
}

CommandsPtr IApplicationMgr::NewCommands ( ) {
    struct Commands * _result = 0;
    HRESULT _hr = raw_NewCommands(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandsPtr(_result, false);
}

HRESULT IApplicationMgr::RaiseError ( long errorCode, _bstr_t errorMessage ) {
    HRESULT _hr = raw_RaiseError(errorCode, errorMessage);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::CloseExecution ( struct TS::Execution * exec ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CloseExecution(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IApplicationMgr::SetAutoCloseExecution ( struct TS::Execution * exec, VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetAutoCloseExecution(exec, val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::GetAutoCloseExecution ( struct TS::Execution * exec ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetAutoCloseExecution(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IApplicationMgr::SetVisible ( struct TS::Execution * exec, VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetVisible(exec, val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::GetVisible ( struct TS::Execution * exec ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetVisible(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TS::IEnginePtr IApplicationMgr::GetEngine ( ) {
    struct TS::IEngine * _result = 0;
    HRESULT _hr = raw_GetEngine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::IEnginePtr(_result, false);
}

CommandPtr IApplicationMgr::GetCommand ( enum CommandKinds cmdKind, long commandIndex ) {
    struct Command * _result = 0;
    HRESULT _hr = raw_GetCommand(cmdKind, commandIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandPtr(_result, false);
}

_bstr_t IApplicationMgr::GetCaptionText ( enum CaptionSources captionSource, VARIANT_BOOL longName, _bstr_t formatExpression ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCaptionText(captionSource, longName, formatExpression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IApplicationMgr::GetImageName ( enum ImageSources imageSource ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetImageName(imageSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IApplicationMgr::ReloadModifiedSequenceFiles ( ) {
    HRESULT _hr = raw_ReloadModifiedSequenceFiles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::CloseAllExecutions ( ) {
    HRESULT _hr = raw_CloseAllExecutions();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

CommandConnectionPtr IApplicationMgr::ConnectCommand ( IDispatch * uiObj, enum CommandKinds cmdKind, long Index, long opts ) {
    struct CommandConnection * _result = 0;
    HRESULT _hr = raw_ConnectCommand(uiObj, cmdKind, Index, opts, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CommandConnectionPtr(_result, false);
}

CaptionConnectionPtr IApplicationMgr::ConnectCaption ( IDispatch * uiObj, enum CaptionSources captionSource, VARIANT_BOOL longName ) {
    struct CaptionConnection * _result = 0;
    HRESULT _hr = raw_ConnectCaption(uiObj, captionSource, longName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return CaptionConnectionPtr(_result, false);
}

IDispatchPtr IApplicationMgr::GetSequenceFileViewMgr ( struct TS::SequenceFile * file ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_GetSequenceFileViewMgr(file, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

IDispatchPtr IApplicationMgr::GetExecutionViewMgr ( struct TS::Execution * exec ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_GetExecutionViewMgr(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

HRESULT IApplicationMgr::LocalizeAllControls ( _bstr_t sectionName ) {
    HRESULT _hr = raw_LocalizeAllControls(sectionName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::RefreshAllViewMgrs ( ) {
    HRESULT _hr = raw_RefreshAllViewMgrs();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::GetLoginOnStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LoginOnStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutLoginOnStart ( VARIANT_BOOL val ) {
    HRESULT _hr = put_LoginOnStart(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetBreakOnStepFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnStepFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutBreakOnStepFailure ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BreakOnStepFailure(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

ApplicationMgrConnectionsPtr IApplicationMgr::GetConnections ( ) {
    struct ApplicationMgrConnections * _result = 0;
    HRESULT _hr = get_Connections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ApplicationMgrConnectionsPtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::GetBreakOnFirstStep ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnFirstStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutBreakOnFirstStep ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BreakOnFirstStep(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetBreakOnSequenceFailure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakOnSequenceFailure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutBreakOnSequenceFailure ( VARIANT_BOOL val ) {
    HRESULT _hr = put_BreakOnSequenceFailure(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

StringsPtr IApplicationMgr::GetCommandLineArguments ( ) {
    struct Strings * _result = 0;
    HRESULT _hr = get_CommandLineArguments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return StringsPtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::GetProcessCommandLine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ProcessCommandLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutProcessCommandLine ( VARIANT_BOOL val ) {
    HRESULT _hr = put_ProcessCommandLine(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SequenceFilesPtr IApplicationMgr::GetSequenceFiles ( ) {
    struct SequenceFiles * _result = 0;
    HRESULT _hr = get_SequenceFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilesPtr(_result, false);
}

ExecutionsPtr IApplicationMgr::GetExecutions ( ) {
    struct Executions * _result = 0;
    HRESULT _hr = get_Executions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ExecutionsPtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::GetLoginLogoutRunning ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LoginLogoutRunning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::GetExecuting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Executing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TS::PropertyObjectFilePtr IApplicationMgr::GetConfigFile ( ) {
    struct TS::PropertyObjectFile * _result = 0;
    HRESULT _hr = get_ConfigFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::PropertyObjectFilePtr(_result, false);
}

void IApplicationMgr::PutConfigFilePath ( _bstr_t val ) {
    HRESULT _hr = put_ConfigFilePath(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IApplicationMgr::GetConfigFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConfigFilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

MRUFilesPtr IApplicationMgr::GetMRUFiles ( ) {
    struct MRUFiles * _result = 0;
    HRESULT _hr = get_MRUFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return MRUFilesPtr(_result, false);
}

void IApplicationMgr::PutReloadSequenceFilesOnStart ( enum ReloadFiles val ) {
    HRESULT _hr = put_ReloadSequenceFilesOnStart(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ReloadFiles IApplicationMgr::GetReloadSequenceFilesOnStart ( ) {
    enum ReloadFiles _result;
    HRESULT _hr = get_ReloadSequenceFilesOnStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IApplicationMgr::GetUserData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_UserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IApplicationMgr::PutUserData ( const _variant_t & val ) {
    HRESULT _hr = put_UserData(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

TS::UIMessagePtr IApplicationMgr::GetCurrentUIMessage ( ) {
    struct TS::UIMessage * _result = 0;
    HRESULT _hr = get_CurrentUIMessage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::UIMessagePtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::GetLogoutClosesSeqFilesAndExecs ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LogoutClosesSeqFilesAndExecs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutLogoutClosesSeqFilesAndExecs ( VARIANT_BOOL val ) {
    HRESULT _hr = put_LogoutClosesSeqFilesAndExecs(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IApplicationMgr::GetReloadModifiedFilesInterval ( ) {
    long _result = 0;
    HRESULT _hr = get_ReloadModifiedFilesInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutReloadModifiedFilesInterval ( long val ) {
    HRESULT _hr = put_ReloadModifiedFilesInterval(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetIsShuttingDown ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsShuttingDown(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::GetIsStarted ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStarted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SequenceFilesPtr IApplicationMgr::OpenSequenceFilesDialog ( ) {
    struct SequenceFiles * _result = 0;
    HRESULT _hr = raw_OpenSequenceFilesDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SequenceFilesPtr(_result, false);
}

VARIANT_BOOL IApplicationMgr::GetApplicationWillExitOnStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ApplicationWillExitOnStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

EntryPointsPtr IApplicationMgr::GetExecutionEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ExecutionEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

EntryPointsPtr IApplicationMgr::GetConfigurationEntryPoints ( ) {
    struct EntryPoints * _result = 0;
    HRESULT _hr = get_ConfigurationEntryPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return EntryPointsPtr(_result, false);
}

TS::SequenceFilePtr IApplicationMgr::GetModelFile ( struct TS::SequenceFile * clientFile, VARIANT_BOOL loadIfNotAlreadyLoaded ) {
    struct TS::SequenceFile * _result = 0;
    HRESULT _hr = raw_GetModelFile(clientFile, loadIfNotAlreadyLoaded, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::SequenceFilePtr(_result, false);
}

AdapterListConnectionPtr IApplicationMgr::ConnectAdapterList ( IDispatch * uiObj ) {
    struct AdapterListConnection * _result = 0;
    HRESULT _hr = raw_ConnectAdapterList(uiObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return AdapterListConnectionPtr(_result, false);
}

HRESULT IApplicationMgr::Refresh ( long opts ) {
    HRESULT _hr = raw_Refresh(opts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::RefreshFile ( struct TS::PropertyObjectFile * file, long opts ) {
    HRESULT _hr = raw_RefreshFile(file, opts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::ReloadConfigFile ( ) {
    HRESULT _hr = raw_ReloadConfigFile();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IApplicationMgr::AddCommandLineArgumentsHelp ( _bstr_t usage, _bstr_t parameterHelp, _bstr_t notes ) {
    HRESULT _hr = raw_AddCommandLineArgumentsHelp(usage, parameterHelp, notes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::CanEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanEdit(editedFile, editKind, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::BeginEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind, SAFEARRAY * objectsToEdit ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_BeginEdit(editedFile, editKind, objectsToEdit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IApplicationMgr::EndEdit ( struct TS::PropertyObjectFile * editedFile, enum TS::EditKinds editKind, SAFEARRAY * editedObjects, VARIANT_BOOL cancelled ) {
    HRESULT _hr = raw_EndEdit(editedFile, editKind, editedObjects, cancelled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IApplicationMgr::ReloadFile ( struct TS::PropertyObjectFile * * file, long options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ReloadFile(file, options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::GetLoginRunning ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LoginRunning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::GetLogoutRunning ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LogoutRunning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

TS::UndoStackPtr IApplicationMgr::GetUndoStack ( ) {
    struct TS::UndoStack * _result = 0;
    HRESULT _hr = get_UndoStack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::UndoStackPtr(_result, false);
}

void IApplicationMgr::PutUndoStack ( struct TS::UndoStack * val ) {
    HRESULT _hr = put_UndoStack(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetIsEditor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEditor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutIsEditor ( VARIANT_BOOL val ) {
    HRESULT _hr = put_IsEditor(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetEditReadOnlyFiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EditReadOnlyFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutEditReadOnlyFiles ( VARIANT_BOOL val ) {
    HRESULT _hr = put_EditReadOnlyFiles(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetMakeStepNamesUnique ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MakeStepNamesUnique(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutMakeStepNamesUnique ( VARIANT_BOOL val ) {
    HRESULT _hr = put_MakeStepNamesUnique(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TS::PerformActionOptions IApplicationMgr::GetPromptForOverwrite ( ) {
    enum TS::PerformActionOptions _result;
    HRESULT _hr = get_PromptForOverwrite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutPromptForOverwrite ( enum TS::PerformActionOptions val ) {
    HRESULT _hr = put_PromptForOverwrite(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TS::PerformActionOptions IApplicationMgr::GetSaveOnClose ( ) {
    enum TS::PerformActionOptions _result;
    HRESULT _hr = get_SaveOnClose(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutSaveOnClose ( enum TS::PerformActionOptions val ) {
    HRESULT _hr = put_SaveOnClose(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AutomaticallyReloadModifiedFilesOptions IApplicationMgr::GetAutomaticallyReloadModifiedFiles ( ) {
    enum AutomaticallyReloadModifiedFilesOptions _result;
    HRESULT _hr = get_AutomaticallyReloadModifiedFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutAutomaticallyReloadModifiedFiles ( enum AutomaticallyReloadModifiedFilesOptions val ) {
    HRESULT _hr = put_AutomaticallyReloadModifiedFiles(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetCreateEmptySequenceFileOnStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CreateEmptySequenceFileOnStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutCreateEmptySequenceFileOnStart ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CreateEmptySequenceFileOnStart(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SelectedPropertyObjectsPtr IApplicationMgr::GetSelectedPropertyObjects ( ) {
    struct SelectedPropertyObjects * _result = 0;
    HRESULT _hr = get_SelectedPropertyObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return SelectedPropertyObjectsPtr(_result, false);
}

TS::PropertyObjectFilePtr IApplicationMgr::GetSelectedPropertyObjectFile ( ) {
    struct TS::PropertyObjectFile * _result = 0;
    HRESULT _hr = get_SelectedPropertyObjectFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TS::PropertyObjectFilePtr(_result, false);
}

void IApplicationMgr::PutSelectedPropertyObjectFile ( struct TS::PropertyObjectFile * val ) {
    HRESULT _hr = put_SelectedPropertyObjectFile(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum ShortcutKeys IApplicationMgr::GetEditModeShortcutKey ( ) {
    enum ShortcutKeys _result;
    HRESULT _hr = get_EditModeShortcutKey(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutEditModeShortcutKey ( enum ShortcutKeys val ) {
    HRESULT _hr = put_EditModeShortcutKey(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IApplicationMgr::GetEditModeShortcutModifier ( ) {
    long _result = 0;
    HRESULT _hr = get_EditModeShortcutModifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutEditModeShortcutModifier ( long val ) {
    HRESULT _hr = put_EditModeShortcutModifier(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::GetCommandLineCanChangeEditMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CommandLineCanChangeEditMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutCommandLineCanChangeEditMode ( VARIANT_BOOL val ) {
    HRESULT _hr = put_CommandLineCanChangeEditMode(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum TS::ExecutionRunStates IApplicationMgr::GetRunState ( struct TS::Execution * exec ) {
    enum TS::ExecutionRunStates _result;
    HRESULT _hr = raw_GetRunState(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum TS::ExecutionTerminationStates IApplicationMgr::GetTerminationState ( struct TS::Execution * exec ) {
    enum TS::ExecutionTerminationStates _result;
    HRESULT _hr = raw_GetTerminationState(exec, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IApplicationMgr::GetUseStepListConfigurations ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseStepListConfigurations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IApplicationMgr::PutUseStepListConfigurations ( VARIANT_BOOL val ) {
    HRESULT _hr = put_UseStepListConfigurations(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IApplicationMgr::ReloadModifiedSequenceFilesEx ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ReloadModifiedSequenceFilesEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

} // namespace TSUI
